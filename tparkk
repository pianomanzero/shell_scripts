#!/bin/bash
################################################################################
##                                                                            ##
## File ID        : tpark.log.sh                                              ##
## Script info    : Provide Overview from log through isi_gather_info         ##
## ETC            :                                                           ##
##                                                                            ##
################################################################################
##                           changing History                                 ##
################################################################################
##                                                                            ##
##   DATE              Who                   Contents changed                 ##
##  ----------   --------------   ------------------------------------------  ##
##  2011.12.01    TaeSung Park    EMC2(Isilon)   First Edition                ##
##  2012.XX.XX    TaeSung Park    Changed a lot of things                     ##
##  2012.06.20    TaeSung Park    Added logic of Category                     ##
##  2012.07.26    TaeSung Park    Added logic of NO inflation                 ##
##  2012.09.23    TaeSung Park    Changed logic considering time complexity   ##
##                                for Panic string and OneFS version check    ##
##  2012.10.02    TaeSung Park    Started to add SyncIQ part                  ##
##  2012.10.04    TaeSung Park    Changed date sort option for OneFS v4,v5    ##
##  2012.12.01    TaeSung Park    Added Cowing, SyncIQ, unsaved minidump etc  ##
##  2013.01.09    TaeSung Park    Added parse_stacks feature for panic        ##
##  2013.02.03    TaeSung Park    Modified logic of checking Time sync        ##
##  2013.02.05    TaeSung Park    Added logic of SMBv2 credit related error   ##
##  2013.02.06    TaeSung Park    Modified logic of External NICs MTU check   ##
##  2013.03.06    TaeSung Park    Displaying isi_gather_info command & time   ##
##  2013.04.01    TaeSung Park    Added latest Firmware Package info v8.2     ##
##  2013.04.02    TaeSung Park    Added logic gathering recent 3 days         ##
##  2013.04.02    TaeSung Park    Added parse_stacks feature for App core     ##
##  2013.04.02    TaeSung Park    Added logic of comparing COWing in v7.0     ##
##  2013.04.02    TaeSung Park    Added latest Drive Firmware info v1.5       ##
##  2013.04.14    TaeSung Park    Added checking log of Bug 100864            ##
##  2013.04.15    TaeSung Park    Added Bug 103781, rpc.lockd hangup issue    ##
##  2013.04.17    TaeSung Park    Added logic to check SmartFail due to Stall ##
##  2013.04.23    TaeSung Park    Added logic to find unsaved minidump on 7.0 ##
##  2013.05.12    TaeSung Park    Bug 104651 : full /var due to the vsfptd    ##
##  2013.05.14    TaeSung Park    Bug 43046                                   ##
##  2013.05.15    TaeSung Park    Added rpc.lockd LKF client_id mismatch      ##
##  2013.05.20    TaeSung Park    Logic to compare CPU count and load avg     ##
##  2013.06.05    TaeSung Park    Logic for not staring with "^panic @" panic ##
##  2013.06.09    TaeSung Park    SMB "Too many open files" error : Bug 97843 ##
##  2013.06.10    TaeSung Park    Node Info part including Config & Serial    ##
##  2013.07.10    TaeSung Park    Added drive stall map(table)-time consuming ##
##  2013.07.14    TaeSung Park    Drive Firmware;Current & Latest Comparison  ##
##  2013.07.22    TaeSung Park    Checking "Listen Queue Overflows"(Thx Mark) ##
##  2013.07.28    TaeSung Park    Checking "Malformed block history"          ##
##  2013.07.28    TaeSung Park    logic "Stack not recorded" in core dumped   ##
##  2013.07.30    TaeSung Park    Added RAM of each nodes                     ##
##  2013.08.18    TaeSung Park    Updated latest Firmware Package info v8.3   ##
##  2013.08.18    TaeSung Park    Modified LIN search pattern against idi.log ##
##  2013.08.18    TaeSung Park    Modified logic for KB-2475                  ##
##  2013.09.22    TaeSung Park    Checking full /var/crash                    ##
##  2013.10.21    TaeSung Park    Fixed a bug on creating stall map           ##
##  2013.11.01    TaeSung Park    Added info regarding Drive Firmware v1.5    ##
##  2013.11.03    TaeSung Park    A100 node config alignment                  ##
##  2013.11.03    TaeSung Park    Modified Drive FW info per v7.1.0.0 code    ##
##  2013.11.03    TaeSung Park    Added Profile info on Drive                 ##
##  2013.11.08    TaeSung Park    Added info how to redirect output to file   ##
##  2013.11.12    TaeSung Park    Updated latest Drive FW Package info v1.6   ##
##  2013.11.17    TaeSung Park    Added Text/Background COLOR Variable        ##
##  2013.11.17    TaeSung Park    Changed already uncompressed file move logic##
##  2013.11.17    TaeSung Park    Added EOSL info against 5.0.X 5.5.X 6.0.X   ##
##  2013.11.18    TaeSung Park    Added explanation of "lk_initiator law"     ##
##  2013.11.25    TaeSung Park    Changed to use parse_stacks2 new version    ##
##  2013.12.08    TaeSung Park    Checked Bug 106939                          ##
##  2013.12.08    TaeSung Park    Modified Firmware check logic               ##
##  2013.12.09    TaeSung Park    logic of current and fixed OneFS version    ##
##  2013.12.10    TaeSung Park    recent three Snapshots created from NDMP    ##
##  2013.12.11    TaeSung Park    added curlogonly option, against unzipped   ##
##  2014.02.10    TaeSung Park    Information about patches installed         ##
##  2014.03.25    TaeSung Park    in case Elvis server /tmp read-only         ##
##  2014.03.26    TaeSung Park    Updated latest Firmware Package info v9.0.1 ##
##  2014.04.01    Mark Foster     Update KB refs to newer IDs                 ##
##                                                                            ##
################################################################################

#---- Text and Background Color ----#
TEXT_RED="[1;31m"
TEXT_GREEN="[1;32m"
TEXT_YELLOW="[1;33m"
TEXT_WARNING="[1;33m"
TEXT_BLUE="[1;34m"
TEXT_MAGENTA="[1;35m"
TEXT_CYAN="[1;36m"
TEXT_WHITE="[1;37m"

BG_RED="[1;41m"
BG_ALERT="[1;41m"
BG_GREEN="[1;42m"
BG_YELLOW="[1;43m"
BG_BLUE="[1;44m"
BG_MAGENTA="[1;45m"
BG_CYAN="[1;46m"
BG_WHITE="[1;47m"

COLOR_RESET="[0m"
#---- Text and Background Color ----#

##################################
###############################
############################
#########################
######################         Shell check for bash
###################            "ps $$" command does not work well on Solaris
################
#############
##########


CURRENT_SHELL=`ps $$ 2> /dev/null |grep sh|awk '{print $5}' 2> /dev/null`
if [[ ${CURRENT_SHELL}x == "x" ]]; then
  CURRENT_SHELL="ksh"
fi

if [[ `ps -ef|grep $$|egrep -v "grep|ps -ef"|grep bash|wc -l` -ne 0 ]]; then
  CURRENT_SHELL="bash"
fi

echo "*** Current Shell might be [${CURRENT_SHELL}] ***"
if [[ $CURRENT_SHELL == "bash" ]]; then
  ECHO="echo -e"
elif [[ $CURRENT_SHELL == "ksh" ]]; then
  ECHO="echo"
elif [[ $CURRENT_SHELL == "zsh" ]]; then
  echo "[1;41m Please Run by bash(1) like [0m"
  echo "[1;41m # bash [this command] [log directory] [0m"
  exit 1
fi

##################################
###############################
############################
#########################
######################         FUNCTIONS
###################
################
#############
##########

#====================================================================
#
# FUNCTION: PRINT_HEAD_TAIL
# PURPOSE:
#

function PRINT_HEAD_TAIL {
  $ECHO "\n[1;33m::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::[0m"
  $ECHO   "    [1;33m$BODY[0m"
  $ECHO   "[1;33m::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::[0m"
}

#
# END OF FUNCTION
#
#====================================================================

#====================================================================
#
# FUNCTION: PRINT_HEAD_LOOP
# PURPOSE:
#

function PRINT_HEAD_LOOP {
  $ECHO "\n    [1;33m::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::[0m"
  $ECHO   "        [1;33m$BODY[0m"
}

#
# END OF FUNCTION
#
#====================================================================

#====================================================================
#
# FUNCTION: PRINT_ALERT
# PURPOSE:
#

function PRINT_ALERT {
  $ECHO "\n   [1;41m==================================================================[0m"
  $ECHO   "   [1;41m====> $ALERT  <====[0m"
  $ECHO   "   [1;41m==================================================================[0m"
}

#
# END OF FUNCTION
#
#====================================================================

#====================================================================
#
# FUNCTION: PRINT_WARNING
# PURPOSE:
#

function PRINT_WARNING {
  $ECHO "\n   [1;33m==================================================================[0m"
  $ECHO   "   [1;33m====> $WARNING  <====[0m"
  $ECHO   "   [1;33m==================================================================[0m"
}

#
# END OF FUNCTION
#
#====================================================================

#====================================================================
#
# FUNCTION: EXEC_CMD_ONLY
# PURPOSE:
#

function EXEC_CMD_ONLY {
    $ECHO "# $CMD"
    eval $CMD
}

#
# END OF FUNCTION
#
#====================================================================


#====================================================================
#
# FUNCTION: PRINT_CURRENT_ONEFS_VERSION
# PURPOSE:
#

function PRINT_CURRENT_ONEFS_VERSION {
  $ECHO "\nThis cluster's version is:"
  CMD="cat ${CLU_ALL}/uname|cut -d' ' -f7|uniq"; EXEC_CMD_ONLY
}

#
# END OF FUNCTION
#
#====================================================================

#====================================================================
#
# FUNCTION: F_COMPARE_CURRENT_VERSION_AND_FIXED_VERSION
# PURPOSE:
#

function F_COMPARE_CURRENT_VERSION_AND_FIXED_VERSION {
  THIS_ISSUE_NOT_FIXED_IN_THIS_CLUSTER=0
  #$ECHO "--> CURRENT_ONEFS_VERSION [$CURRENT_ONEFS_VERSION] <--"
  CURRENT_ONEFS_VERSION_FIRST=`echo $CURRENT_ONEFS_VERSION|awk -F\. '{print $1}'`
  CURRENT_ONEFS_VERSION_SECOND=`echo $CURRENT_ONEFS_VERSION|awk -F\. '{print $2}'`
  CURRENT_ONEFS_VERSION_THIRD=`echo $CURRENT_ONEFS_VERSION|awk -F\. '{print $3}'`
  CURRENT_ONEFS_VERSION_FORTH=`echo $CURRENT_ONEFS_VERSION|awk -F\. '{print $4}'`
  #$ECHO "Current : [$CURRENT_ONEFS_VERSION_FIRST] [$CURRENT_ONEFS_VERSION_SECOND] [$CURRENT_ONEFS_VERSION_THIRD] [$CURRENT_ONEFS_VERSION_FORTH]"
  FIXED_ONEFS_V655X_FIRST=`echo $FIXED_ONEFS_V655X|awk -F\. '{print $1}'`
  FIXED_ONEFS_V655X_SECOND=`echo $FIXED_ONEFS_V655X|awk -F\. '{print $2}'`
  FIXED_ONEFS_V655X_THIRD=`echo $FIXED_ONEFS_V655X|awk -F\. '{print $3}'`
  FIXED_ONEFS_V655X_FORTH=`echo $FIXED_ONEFS_V655X|awk -F\. '{print $4}'`
  #$ECHO "Fixed in v6.5.5.X [$FIXED_ONEFS_V655X_FIRST] [$FIXED_ONEFS_V655X_SECOND] [$FIXED_ONEFS_V655X_THIRD] [$FIXED_ONEFS_V655X_FORTH]"
  # Current OneFS v6.5.5.X #
  if [[ $CURRENT_ONEFS_VERSION_FIRST -eq 6 && $CURRENT_ONEFS_VERSION_SECOND -eq 5 && $CURRENT_ONEFS_VERSION_THIRD -eq 5 ]]; then
    # Fixed OneFS version is 6.5.5.X #
    if [[ $FIXED_ONEFS_V655X_FIRST -eq 6 && $FIXED_ONEFS_V655X_SECOND -eq 5 && $FIXED_ONEFS_V655X_THIRD -eq 5 ]]; then
      if [[ $CURRENT_ONEFS_VERSION_FORTH -ge $FIXED_ONEFS_V655X_FORTH ]]; then
        #$ECHO "--> fixed in this version <--"
        THIS_ISSUE_NOT_FIXED_IN_THIS_CLUSTER=1
      fi
    fi
  fi
  FIXED_ONEFS_V655X=""
  FIXED_ONEFS_V701X=""
  FIXED_ONEFS_V702X=""
  FIXED_ONEFS_V710X=""
}

#
# END OF FUNCTION
#
#====================================================================



#====================================================================
#
# FUNCTION: EXEC_CMD
# PURPOSE:
#

function EXEC_CMD {
  case $CATEGORY in
    "") RUN_OR_NOT=0 ;;
    "stall")      if [[ $STALL_CHECK      -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "panic")      if [[ $PANIC_CHECK      -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "protection") if [[ $PROTECTION_CHECK -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "snapshot")   if [[ $SNAPSHOT_CHECK   -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "mesg")       if [[ $MESG_CHECK       -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "core")       if [[ $CORE_CHECK       -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "hangdump")   if [[ $HANGDUMP_CHECK   -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "lock")       if [[ $LOCK_CHECK       -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "disk")       if [[ $DISK_CHECK       -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "network")    if [[ $NETWORK_CHECK    -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "basic")      if [[ $BASIC_CHECK      -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "cpu")        if [[ $CPU_CHECK        -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "runq")       if [[ $RUNQ_CHECK       -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "perf")       if [[ $PERF_CHECK       -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "smb")        if [[ $SMB_CHECK        -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "nfs")        if [[ $NFS_CHECK        -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "etc")        if [[ $ETC_CHECK        -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "firmware")   if [[ $FIRMWARE_CHECK   -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "synciq")     if [[ $SYNCIQ_CHECK     -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "cow")        if [[ $COW_CHECK        -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
    "test")       if [[ $TEST_CHECK       -eq 1 ]]; then RUN_OR_NOT=1 ; else RUN_OR_NOT=0 ; fi ;;
  esac

  if [[ $ALL_CHECK -eq 1 ]]; then
    RUN_OR_NOT=1;
  fi

  if [[ $RUN_OR_NOT -eq 1 ]]; then
    PRINT_HEAD_TAIL
    if [[ ${CMD}_x != "_x" ]]; then
      $ECHO "# $CMD"
      eval $CMD
    fi
  fi
}

#
# END OF FUNCTION
#
#====================================================================

##################################
###############################
############################
#########################
######################         PRE check : shell, environment
###################
################
#############
##########

CATEGORY_ALL=$*
CATEGORY_EACH=""
SKIP_1ST_ARG=1
RUN_LOG_FILE="/home/tpark/RUN_LOG_FILE"
echo "`date` : `whoami 2> /dev/null` : $PWD : $0 : $*" >> $RUN_LOG_FILE 2> /dev/null

# First Argument MUST be log directory 
# or, could be omitted, then assume current directory is log directory.
# That is, when first argument is set, sub option(s) will be working.
if [[ $# -eq 1 || $# -eq 0 ]]; then
  ALL_CHECK=1
# when set arguments are [log directory] allnostack
elif [[ $# -eq 2 && $2 == "allnostack" ]]; then
  ALL_CHECK=1
  NO_STACK=1
elif [[ $# -eq 3 && $2 == "allnostack" && $3 == "curlogonly" ]]; then
  ALL_CHECK=1
  NO_STACK=1
  # below option can be used for checking current log file, e.g) NOT messages.0 BUT messages only
  CURLOGONLY=1
else
  clear
  for CATEGORY_EACH in $CATEGORY_ALL
  do
    if [[ $SKIP_1ST_ARG -eq 1 ]]; then
      SKIP_1ST_ARG=0
      continue
    fi

    case $CATEGORY_EACH in
      "help"|"--help"|"-h"|"--h")
        BODY="\n How to run : # bash <this_script_name> <log_directory> [sub_option [sub_option] ... ]\n\nPossible Sub options are: \n\tbasic\n\tstall\n\tpanic\n\tprotection\n\tmesg\n\tsnapshot\n\tcore\n\thangdump\n\tlock\n\tnetwork\n\tdisk\n\tcpu\n\trunq\n\tperf\n\tsmb\n\tnfs\n\tetc\n\tfirmware\n\tsynciq\n\tcow\n\ttest\n"; PRINT_HEAD_TAIL
        exit 0
        ;;
      "stall")      STALL_CHECK=1 ;;
      "panic")      PANIC_CHECK=1 ;;
      "protection") PROTECTION_CHECK=1 ;;
      "mesg")       MESG_CHECK=1 ;;
      "snapshot")   SNAPSHOT_CHECK=1 ;;
      "core")       CORE_CHECK=1 ;;
      "hangdump")   HANGDUMP_CHECK=1 ;;
      "lock")       LOCK_CHECK=1 ;;
      "network")    NETWORK_CHECK=1 ;;
      "basic")      BASIC_CHECK=1 ;;
      "disk")       DISK_CHECK=1 ;;
      "cpu")        CPU_CHECK=1 ;;
      "runq")       RUNQ_CHECK=1 ;;
      "perf")       PERF_CHECK=1 ;;
      "smb")        SMB_CHECK=1 ;;
      "nfs")        NFS_CHECK=1 ;;
      "etc")        ETC_CHECK=1 ;;
      "firmware")   FIRMWARE_CHECK=1 ;;
      "synciq")     SYNCIQ_CHECK=1 ;;
      "cow")        COW_CHECK=1 ;;
      "test")       TEST_CHECK=1 ;;

#-- Sub Minus options --#
      # below option is working only with panic and core options
      "nostack")    NO_STACK=1 ;;
#-- Sub Minus options --#

      *) $ECHO "==> Unknown Category Option [$CATEGORY_EACH]" ;;
    esac
    $ECHO "Category Option is [$CATEGORY_EACH]"
  done
fi

EXEC_OS=`uname -s`
case $EXEC_OS in
  "Isilon OneFS")
    echo "This system is [Isilon OneFS]"
    ZCAT="gzcat" 
    ;;
  "Linux")
    echo "This system is [Linux]"
    ZCAT="zcat" 
    ;;
  "SunOS")
    echo "This system is [Solaris]" 
    ZCAT="gzcat"
    RUNNING_ON_SOLARIS=1
    ;;
esac

if [[ $# -eq 0 ]]; then
  $ECHO "\n[1;41m--------------------------------------------------------------------------------------------------------------------[0m"
  $ECHO "[1;41m Please specify log directory with 1st argument, will assume it as current directory, but sub-option would not work [0m"
  $ECHO "[1;41m--------------------------------------------------------------------------------------------------------------------[0m\n"
  IN_DIR="."
else
  if [[ $# -ge 1 ]]; then
    if [[ $1 == "help" || $1 == "--help" || $1 == "-h" || $1 == "--h" ]]; then
BODY="\n How to run : # bash <this_script_name> <log_directory> [sub_option [sub_option] ... ]\n\nPossible Sub options are: \n\tbasic\n\tstall\n\tpanic\n\tprotection\n\tmesg\n\tsnapshot\n\tcore\n\tlock\n\tnetwork\n\tdisk\n\tcpu\n\trunq\n\tperf\n\tsmb\n\tnfs\n\tetc\n\tfirmware\n\tsynciq\n\tcow\n\ttest\n"; PRINT_HEAD_TAIL
        exit 0
    else
      IN_DIR=$1
    fi
  fi
fi

if [[ ! -f $IN_DIR/nodes_info ]]; then
  ALERT=" Error : NOT Found [$IN_DIR/nodes_info] file "; PRINT_ALERT
  $ECHO "\n *** In case you did NOT specify log directory with 1st argument, sub-option would not work. ***\n"
  exit 1
fi

PID=$$
TIME_FOR_FILE=`date +"%H%M%S"`
touch /tmp/___touch_test___${PID}_${TIME_FOR_FILE}
TMP_DIR_TEST_RESULT=$?
if [[ $TMP_DIR_TEST_RESULT -ne 0 ]]; then
  TEMP_FILE="/home/tpark/tpark.scirpt.temp/__TEMP_${PID}_${TIME_FOR_FILE}"
  TEMP_FILE_2="/home/tpark/tpark.scirpt.temp/__TEMP2_${PID}_${TIME_FOR_FILE}"
  TEMP_FILE_3="/home/tpark/tpark.scirpt.temp/__TEMP3_${PID}_${TIME_FOR_FILE}"
  TEMP_PANIC_OUTPUT="/home/tpark/tpark.scirpt.temp/__TEMP_PANIC_${PID}_${TIME_FOR_FILE}"
  TEMP_DIR="home/tpark/tpark.scirpt.temp"
else
  rm -f /tmp/___touch_test___${PID}_${TIME_FOR_FILE}
  TEMP_FILE="/tmp/__TEMP_${PID}_${TIME_FOR_FILE}"
  TEMP_FILE_2="/tmp/__TEMP2_${PID}_${TIME_FOR_FILE}"
  TEMP_FILE_3="/tmp/__TEMP3_${PID}_${TIME_FOR_FILE}"
  TEMP_PANIC_OUTPUT="/tmp/__TEMP_PANIC_${PID}_${TIME_FOR_FILE}"
  TEMP_DIR="tmp"
fi

SKIP_THIS=0
GNU_GREP="/usr/local/bin/grep"
GNU_EGREP="/usr/local/bin/egrep"
if [[ $CURRENT_SHELL == "ksh" ]]; then
  if [[ ! -f $GNU_GREP ]]; then
    SKIP_THIS=1
  fi
elif [[ $CURRENT_SHELL == "bash" ]]; then
  if [[ $RUNNING_ON_SOLARIS -ne 1 ]]; then
    GNU_GREP="grep"
    GNU_EGREP="egrep"
  fi
fi

if [[ -f /usr/bin/zgrep ]]; then
  ZGREP="/usr/bin/zgrep"
  ZGREP_E="/usr/bin/zgrep -E"
elif [[ -f /usr/bin/gzgrep ]]; then
  ZGREP="/usr/bin/gzgrep"
  ZGREP_E="/usr/bin/gzgrep -e"
else
  ZGREP="grep"
  echo "WARNING : zgrep or gzrep does not exist"
fi

if [[ -f /usr/local/bin/md5 ]]; then
  MD5="/usr/local/bin/md5"
elif [[ -f /usr/bin/md5sum ]]; then
  MD5="/usr/bin/md5sum"
elif [[ -f /usr/bin/md5 ]]; then
  MD5="/usr/bin/md5"
else
  MD5="md5"
fi

#sFLAG=0
#while getopts "s"  C
#do
#  case $C in
#    s) sFLAG=1
#       ;;
#  esac
#done

#
# END OF PRE check : shell, environment
#
#====================================================================

##################################
###############################
############################
#########################
######################         Global Variables
###################
################
#############
##########

CLUSTER_NODE_FIRST=`cat $IN_DIR/nodes_info|awk '{print $3}'|grep -v node|head -1`
CLUSTER_NAME_DASH_COUNT_TEMP=`echo ${CLUSTER_NODE_FIRST}|awk 'BEGIN{FS="-"}{for(i=1;i<=NF;i++)c++}END{print c}'`
((CLUSTER_NAME_DASH_COUNT=CLUSTER_NAME_DASH_COUNT_TEMP-1))
if [[ ${CLUSTER_NAME_DASH_COUNT} -eq 1 ]]; then
  CLUSTER_NAME=`cat $IN_DIR/nodes_info|awk '{print $3}'|grep -v node|head -1|cut -d- -f1`
else
  for INPUT in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64
  do
    if [[ `echo ${CLUSTER_NODE_FIRST}|grep "\-${INPUT}$"|wc -l` -eq 1 ]]; then
      CLUSTER_NAME=`echo ${CLUSTER_NODE_FIRST}|sed "s:-${INPUT}$::"`
      break
    fi
  done
fi
CLUSTER_NODE=`cat $IN_DIR/nodes_info|awk '{print $3}'|grep -v node`

CLU_ALL="${IN_DIR}/${CLUSTER_NAME}-*"
CLU_ALL_LOG="${CLU_ALL}/varlog.tar/log"
CLU_LATEST_MSG="${CLU_ALL_LOG}/messages"
CLU_ALL_LOG_MSG="${CLU_ALL_LOG}/messages*"
CLU_ALL_LOG_LWIOD="${CLU_ALL_LOG}/lwiod.log*"
CLU_ALL_LOG_ISI_SNAPSHOT_D="${CLU_ALL_LOG}/isi_snapshot_d.log*"
CLU_ALL_LOG_ISI_MIGRATE="${CLU_ALL_LOG}/isi_migrate.log*"
CLU_ALL_ISI_RADISH="${CLU_ALL}/isi_radish"
CLU_1ST="${IN_DIR}/${CLUSTER_NODE_FIRST}"
CLU_1ST_LOG="${IN_DIR}/${CLUSTER_NODE_FIRST}/varlog.tar/log"
CLU_1ST_LOG_MSG="${IN_DIR}/${CLUSTER_NODE_FIRST}/varlog.tar/log/messages*"
#OLD_DATE_FORMAT="Jan .[0-9]|Feb .[0-9]|Mar .[0-9]|Apr .[0-9]|May .[0-9]|Jun .[0-9]|Jul .[0-9]|Aug .[0-9]|Sep .[0-9]|Oct .[0-9]|Nov .[0-9]|Dec .[0-9]"
OLD_DATE_FORMAT="[Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec] .[0-9]"

IS_ONEFS_version5=0
IS_ONEFS_version60=0
IS_ONEFS_version7=0
MONTH_SORT=""
if [[ `cat ${CLU_ALL}/uname|cut -d' ' -f5-8|grep "Isilon OneFS v5"|wc -l` -ne 0 ]]; then
  IS_ONEFS_version5=1
  ALERT="               Cluster version is v5.X               "; PRINT_ALERT
  ALERT="    OneFS 5.0.X and 5.5.X EOSL date is Dec-31-2013   "; PRINT_ALERT
  MONTH_SORT="-M"
elif [[ `cat ${CLU_ALL}/uname|cut -d' ' -f5-8|grep "Isilon OneFS v6.0."|wc -l` -ne 0 ]]; then
  IS_ONEFS_version60=1
  ALERT="               Cluster version is v6.0.X             "; PRINT_ALERT
  #ALERT="         OneFS 6.0.X EOSL date is Feb-14-2014        "; PRINT_ALERT
  ALERT="         OneFS 6.0.X EOSL date is Aug-31-2014        "; PRINT_ALERT
elif [[ `cat ${CLU_ALL}/uname|cut -d' ' -f5-8|grep "Isilon OneFS v7"|wc -l` -ne 0 ]]; then
  IS_ONEFS_version7=1
  ALERT="               Cluster version is v7.X               "; PRINT_ALERT
fi

TIMEZONE_ENV=`grep timezone ${CLU_1ST}/etcifs.tar/ifs/array.xml|head -1|cut -d">" -f2|cut -d"<" -f1`
if [[ -f ${CLU_1ST_LOG}/vmlog.0 ]]; then
  TIMEZONE=`head -3 ${CLU_1ST_LOG}/vmlog.0|tail -1|awk '{print $5}'`
else
  if [[ -f ${CLU_1ST_LOG}/vmlog.0.gz ]]; then
    TIMEZONE=`$ZCAT ${CLU_1ST_LOG}/vmlog.0.gz|head -3|tail -1|awk '{print $5}'`
  else
    if [[ `cat ${CLU_1ST_LOG}/vmlog|wc -l` -eq 1 ]]; then
      TIMEZONE=""
    else
      TIMEZONE=`head -3 ${CLU_1ST_LOG}/vmlog|tail -1|awk '{print $5}'`
    fi
  fi
fi

if [[ $TIMEZONE_ENV == "" ]]; then
  case $TIMEZONE in
    "GMT") TIMEZONE_ENV="GMT" ;;
    "KST") TIMEZONE_ENV="Asia/Seoul" ;;
    "JST") TIMEZONE_ENV="Japan" ;;
    "SGT") TIMEZONE_ENV="Singapore" ;;
    "EDT"|"EST"|"CEST") TIMEZONE_ENV="America/New_York" ;;
    "PDT"|"PST") TIMEZONE_ENV="America/Los_Angeles" ;;
    #"CST") TIMEZONE_ENV="Shanghai" ;;
    "CST") TIMEZONE_ENV="America/Chicago" ;;
    "BST") TIMEZONE_ENV="Europe/London" ;;
    *) TIMEZONE_ENV=""
       ALERT="              Please check the timezone              "; PRINT_ALERT
       TIMEZONE_ENV_NULL=1
    ;;
  esac
fi

if [[ -f ${IN_DIR}/package_info.xml ]]; then
  ISI_GATHER_INFO_COMMAND=`cat ${IN_DIR}/package_info.xml|awk '{p1=index($0,"<command>");p2=index($0,"</command>");u=substr($0,p1+9,p2-p1-9);print u}'`
  ISI_GATHER_INFO_DATE=`cat ${IN_DIR}/package_info.xml|awk '{p1=index($0,"<gather_date>");p2=index($0,"</gather_date>");u=substr($0,p1+13,p2-p1-13);print u}'`
  ((ISI_GATHER_INFO_DATE_1DAY_AGO=ISI_GATHER_INFO_DATE-86400))
  ((ISI_GATHER_INFO_DATE_2DAY_AGO=ISI_GATHER_INFO_DATE-172800))
  ((ISI_GATHER_INFO_DATE_3DAY_AGO=ISI_GATHER_INFO_DATE-259200))
  ISI_GATHER_INFO_LOCAL_DATE=`env TZ=${TIMEZONE_ENV} perl -e "print scalar localtime($ISI_GATHER_INFO_DATE)"`
  DATE_LOG_GATHERED_YEAR=`env TZ=${TIMEZONE_ENV} perl -e "print ((localtime($ISI_GATHER_INFO_DATE))[5])"`
  DATE_LOG_GATHERED_YEAR_1DAY_AGO=`env TZ=${TIMEZONE_ENV} perl -e "print ((localtime($ISI_GATHER_INFO_DATE_1DAY_AGO))[5])"`
  DATE_LOG_GATHERED_YEAR_2DAY_AGO=`env TZ=${TIMEZONE_ENV} perl -e "print ((localtime($ISI_GATHER_INFO_DATE_2DAY_AGO))[5])"`
  DATE_LOG_GATHERED_YEAR_3DAY_AGO=`env TZ=${TIMEZONE_ENV} perl -e "print ((localtime($ISI_GATHER_INFO_DATE_3DAY_AGO))[5])"`
  ((DATE_LOG_GATHERED_YEAR+=1900))
  ((DATE_LOG_GATHERED_YEAR_1DAY_AGO+=1900))
  ((DATE_LOG_GATHERED_YEAR_2DAY_AGO+=1900))
  ((DATE_LOG_GATHERED_YEAR_3DAY_AGO+=1900))
  DATE_LOG_GATHERED_MONTH=`env TZ=${TIMEZONE_ENV} perl -e "print ((localtime($ISI_GATHER_INFO_DATE))[4])"`
  DATE_LOG_GATHERED_MONTH_1DAY_AGO=`env TZ=${TIMEZONE_ENV} perl -e "print ((localtime($ISI_GATHER_INFO_DATE_1DAY_AGO))[4])"`
  DATE_LOG_GATHERED_MONTH_2DAY_AGO=`env TZ=${TIMEZONE_ENV} perl -e "print ((localtime($ISI_GATHER_INFO_DATE_2DAY_AGO))[4])"`
  DATE_LOG_GATHERED_MONTH_3DAY_AGO=`env TZ=${TIMEZONE_ENV} perl -e "print ((localtime($ISI_GATHER_INFO_DATE_3DAY_AGO))[4])"`
  ((DATE_LOG_GATHERED_MONTH+=1))
  ((DATE_LOG_GATHERED_MONTH_1DAY_AGO+=1))
  ((DATE_LOG_GATHERED_MONTH_2DAY_AGO+=1))
  ((DATE_LOG_GATHERED_MONTH_3DAY_AGO+=1))
  DATE_LOG_GATHERED_MONTH=`printf %02d $DATE_LOG_GATHERED_MONTH`
  DATE_LOG_GATHERED_MONTH_1DAY_AGO=`printf %02d $DATE_LOG_GATHERED_MONTH_1DAY_AGO`
  DATE_LOG_GATHERED_MONTH_2DAY_AGO=`printf %02d $DATE_LOG_GATHERED_MONTH_2DAY_AGO`
  DATE_LOG_GATHERED_MONTH_3DAY_AGO=`printf %02d $DATE_LOG_GATHERED_MONTH_3DAY_AGO`
  DATE_LOG_GATHERED_DAY=`env TZ=${TIMEZONE_ENV} perl -e "print ((localtime($ISI_GATHER_INFO_DATE))[3])"`
  DATE_LOG_GATHERED_DAY_1DAY_AGO=`env TZ=${TIMEZONE_ENV} perl -e "print ((localtime($ISI_GATHER_INFO_DATE_1DAY_AGO))[3])"`
  DATE_LOG_GATHERED_DAY_2DAY_AGO=`env TZ=${TIMEZONE_ENV} perl -e "print ((localtime($ISI_GATHER_INFO_DATE_2DAY_AGO))[3])"`
  DATE_LOG_GATHERED_DAY_3DAY_AGO=`env TZ=${TIMEZONE_ENV} perl -e "print ((localtime($ISI_GATHER_INFO_DATE_3DAY_AGO))[3])"`
  DATE_LOG_GATHERED_DAY=`printf %02d $DATE_LOG_GATHERED_DAY`
  DATE_LOG_GATHERED_DAY_1DAY_AGO=`printf %02d $DATE_LOG_GATHERED_DAY_1DAY_AGO`
  DATE_LOG_GATHERED_DAY_2DAY_AGO=`printf %02d $DATE_LOG_GATHERED_DAY_2DAY_AGO`
  DATE_LOG_GATHERED_DAY_3DAY_AGO=`printf %02d $DATE_LOG_GATHERED_DAY_3DAY_AGO`
  DATE_LOG_GATHERED_FULL="${DATE_LOG_GATHERED_YEAR}-${DATE_LOG_GATHERED_MONTH}-${DATE_LOG_GATHERED_DAY}T"
  DATE_LOG_GATHERED_FULL_1DAY_AGO="${DATE_LOG_GATHERED_YEAR_1DAY_AGO}-${DATE_LOG_GATHERED_MONTH_1DAY_AGO}-${DATE_LOG_GATHERED_DAY_1DAY_AGO}T"
  DATE_LOG_GATHERED_FULL_2DAY_AGO="${DATE_LOG_GATHERED_YEAR_2DAY_AGO}-${DATE_LOG_GATHERED_MONTH_2DAY_AGO}-${DATE_LOG_GATHERED_DAY_2DAY_AGO}T"
  DATE_LOG_GATHERED_FULL_3DAY_AGO="${DATE_LOG_GATHERED_YEAR_3DAY_AGO}-${DATE_LOG_GATHERED_MONTH_3DAY_AGO}-${DATE_LOG_GATHERED_DAY_3DAY_AGO}T"
  #$ECHO "DATE_LOG_GATHERED_FULL : [${DATE_LOG_GATHERED_FULL}]"
  #$ECHO "DATE_LOG_GATHERED_FULL_1DAY_AGO : [${DATE_LOG_GATHERED_FULL_1DAY_AGO}]"
  #$ECHO "DATE_LOG_GATHERED_FULL_2DAY_AGO : [${DATE_LOG_GATHERED_FULL_2DAY_AGO}]"
  #$ECHO "DATE_LOG_GATHERED_FULL_3DAY_AGO : [${DATE_LOG_GATHERED_FULL_3DAY_AGO}]"
fi

CURRENT_ONEFS_VERSION=`cat ${CLU_ALL}/uname|cut -d' ' -f7|uniq|sed 's:v::'`

#
# END OF Global Variables
#
#====================================================================

##################################
###############################
############################
#########################
######################         inflating compressed *gz & *bz2 files
###################            under Node-#/varlog.tar/log
################
#############
##########

DO_UNCOMPRESS=0
ALREADY_UNCOMPRESSED=0
UNCOMPRESSED_COUNT=`ls -1 ${CLU_ALL_LOG}|egrep "gz$|bz2$"|wc -l`
if [[ $RUNNING_ON_SOLARIS -eq 1 ]]; then
  # Target log direcotry is NOT log_server, it is local file system.
  CURRENT_MOUNT_DIR=`df -k ${IN_DIR}|xargs|awk '{print $13}'`
  if [[ `mount -v|grep "on $CURRENT_MOUNT_DIR "|grep nfs|wc -l` -ge 1 ]]; then
    $ECHO "# ls -1 ${CLU_ALL_LOG}|egrep \"gz\$|bz2\$\"|wc -l"
    ls -1 ${CLU_ALL_LOG}|egrep "gz$|bz2$"|wc -l
    $ECHO "\n   Confirmed this target directory is NFS mounted file system"
    ALERT="       Uncompressing Process might be skipped        "; PRINT_ALERT
    # if the count of uncompressed files is under 100, I will assume files were already uncompressed.
    if [[ $UNCOMPRESSED_COUNT -le 100 ]]; then
      $ECHO "if the count of uncompressed files is under 100, I will assume files were already uncompressed."
      ALREADY_UNCOMPRESSED=1
    fi
  else
    $ECHO "\n   Confirmed this target directory is local file system\n"
    DO_UNCOMPRESS=1
  fi
else
  CURRENT_MOUNT_DIR=`df -k ${IN_DIR}|xargs|awk '{print $13}'`
  if [[ `mount -v|grep "on $CURRENT_MOUNT_DIR "|grep nfs|wc -l` -ge 1 ]]; then
    $ECHO "\n  Current script might be executing toward original files on log server, \"seastore\"\n  So, Uncompressing Process could be skipped\n"
    $ECHO "# ls -1 ${CLU_ALL_LOG}|egrep \"gz\$|bz2\$\"|wc -l"
    $ECHO "$UNCOMPRESSED_COUNT"
    if [[ $UNCOMPRESSED_COUNT -eq 0 ]]; then
      DO_UNCOMPRESS=1
    fi
    if [[ $UNCOMPRESSED_COUNT -gt 0 ]]; then
      $ECHO "-------------------------------------------------------------------------------------------------"
      $ECHO "  If you enter \"n\" in the following, this script will check it ONLY using latest messages file"
      $ECHO "  messages.0 ... messages.19 files will not be checked"
      $ECHO "  So, I would recommend enter \"y\", however, it would take some more time...."
      $ECHO "-------------------------------------------------------------------------------------------------"
      $ECHO "Do you want to uncompress files on \"seastore\" server [y/n] : \c "
      read YES_NO
      if [[ $YES_NO == "y" ]]; then
        DO_UNCOMPRESS=1
      fi
    fi
    # if the count of uncompressed files is under 100, I will assume files were already uncompressed.
    if [[ $UNCOMPRESSED_COUNT -le 100 ]]; then
      $ECHO "if the count of uncompressed files is under 100, I will assume files were already uncompressed."
      ALREADY_UNCOMPRESSED=1
    fi
  else
    $ECHO "\n   Confirmed this target directory is local file system\n"
    DO_UNCOMPRESS=1
  fi
fi

if [[ $DO_UNCOMPRESS -eq 1 ]] ;then
  $ECHO "\n  ===> Confirmed, processing uncompress job\n"
  if [[ `ls -1 ${CLU_ALL_LOG}|egrep "gz$|bz2$"|wc -l` -ne 0 ]]; then
    $ECHO "\n[1;44m====================== inflating compressed files =======================[0m"

    $ECHO "# ls -1 ${CLU_ALL_LOG}|egrep \"gz\$|bz2\$\"|wc -l"
    ls -1 ${CLU_ALL_LOG}|egrep "gz\$|bz2\$"|wc -l

    for EACH_NODE in $CLUSTER_NODE
    do
      $ECHO "( cd $IN_DIR/$EACH_NODE/varlog.tar/log ; gunzip -f *gz )"
      ( cd $IN_DIR/$EACH_NODE/varlog.tar/log ; gunzip *gz )
      $ECHO "( cd $IN_DIR/$EACH_NODE/varlog.tar/log ; bzip2 -f -d *bz2 )"
      ( cd $IN_DIR/$EACH_NODE/varlog.tar/log ; bzip2 -d *bz2 )
      sleep 1
    done

    if [[ `ls -1 ${CLU_ALL_LOG}|egrep "gz$|bz2$"|wc -l` -ne 0 ]]; then
      #! test -d  $PWD/$IN_DIR/bz2_or_gz_orginal_files && mkdir -p $PWD/$IN_DIR/bz2_or_gz_orginal_files
      ! test -d  $IN_DIR/bz2_or_gz_orginal_files && mkdir -p $IN_DIR/bz2_or_gz_orginal_files
      RT_VALUE=$?
      if [[ $RT_VALUE -eq 0 ]]; then
        $ECHO "\n\nDo you want to move already uncompressed files [y/n] : \c "
        read YES_NO
        if [[ $YES_NO == "y" ]]; then
          for EACH_NODE in $CLUSTER_NODE
          do
            ! test -d  $IN_DIR/bz2_or_gz_orginal_files/${EACH_NODE} && mkdir -p $IN_DIR/bz2_or_gz_orginal_files/${EACH_NODE}
            MV_DIR="$IN_DIR/bz2_or_gz_orginal_files/${EACH_NODE}"
            $ECHO "\nAlready uncompressed files will be moved to ${MV_DIR}\n"
            ( cd $IN_DIR/$EACH_NODE/varlog.tar/log ; mv *gz $MV_DIR 2>/dev/null )
            ( cd $IN_DIR/$EACH_NODE/varlog.tar/log ; mv *bz2 $MV_DIR 2>/dev/null )
            sleep 1
          done
        fi
      fi
    fi
  fi
fi

#
# END OF inflating compressed *gz & *bz2 files under Node-#/varlog.tar/log
#
#====================================================================

#
# Checking about whether it was upgraded from OneFS v4 or v5
#
$ECHO "...... Checking whether this cluster has been upgraded from OneFS v4.X or v5.X"
$ECHO "........... It will take some time"
if [[ `egrep ": Isilon OneFS v4|: Isilon OneFS v5" ${CLU_ALL_LOG_MSG}|wc -l` -ne 0 ]]; then
  PREVIOUS_CURRENT_V4_V5=1
  if [[ IS_ONEFS_version5 -eq 0 ]]; then
    WARNING="This cluster has been upgraded from OneFS v4.X or v5.X"; PRINT_WARNING
  fi
fi


#
# Checking whether user has .bugz_cookie on his/her home dir in order to run parse_stacks tools
#
# parse_stacks2 tool does not require .bugz_cookie file anymore
#
BUGZ_COOKIE_EXIST=1

# commented out below on 11/25/2013
#
#if [[ -f ~/.bugz_cookie ]]; then
#  BUGZ_COOKIE_EXIST=1
#else
#  BUGZ_COOKIE_EXIST=0
#  ALERT="You do not have \".bugz_cookie\" file on your home directory for running \"parse_stacks\" tool"; PRINT_ALERT
#fi

##################################
###############################
############################
#########################
######################         Override Global Variables
###################
################
#############

if [[ $DO_UNCOMPRESS -eq 0 && $ALREADY_UNCOMPRESSED -eq 0 ]]; then
  CLU_ALL_LOG_MSG=$CLU_LATEST_MSG
  CLU_ALL_LOG_ISI_SNAPSHOT_D="${CLU_ALL_LOG}/isi_snapshot_d.log"
  CLU_1ST_LOG_MSG="${IN_DIR}/${CLUSTER_NODE_FIRST}/varlog.tar/log/messages"
  CLU_ALL_LOG_LWIOD="${CLU_ALL_LOG}/lwiod.log"
fi

if [[ $CURLOGONLY -eq 1 ]]; then
  CLU_ALL_LOG_MSG=$CLU_LATEST_MSG
  CLU_ALL_LOG_ISI_SNAPSHOT_D="${CLU_ALL_LOG}/isi_snapshot_d.log"
  CLU_1ST_LOG_MSG="${IN_DIR}/${CLUSTER_NODE_FIRST}/varlog.tar/log/messages"
  CLU_ALL_LOG_LWIOD="${CLU_ALL_LOG}/lwiod.log"
fi

#
# END OF Override Global Variables
#
#====================================================================

##################################
###############################
############################
#########################
######################         M A I N     Procedure
###################
################
#############
##########

$ECHO "\n[1;42m=============================== START ===================================[0m"

OUTPUT_FILE="$CLUSTER_NAME.output"
$ECHO "TimeZone : [$TIMEZONE_ENV] : [$TIMEZONE]"

CPU_COUNTS_1ST_NODE=`cat ${CLU_1ST}/ps|egrep cpu[0-9]|wc -l|awk '{print $1}'`
$ECHO "First NODE is [$CLUSTER_NODE_FIRST]"
if [[ $CPU_COUNTS_1ST_NODE -eq 0 ]]; then
  CPU_COUNTS_1ST_NODE=400
else
  $ECHO "CPU COUNTS on First NODE is [$CPU_COUNTS_1ST_NODE]"
  ((CPU_COUNTS_1ST_NODE=CPU_COUNTS_1ST_NODE*100))
fi


CATEGORY="basic"; BODY="uname"
CMD="cat ${CLU_ALL}/uname|cut -d' ' -f8|sort|uniq|wc -l"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `eval $CMD` -eq 1 ]]; then
    cat ${CLU_ALL}/uname|cut -d' ' -f1-8|head -1
  else # I have never seen this kind of mixed version cluster but....
    cat ${CLU_ALL}/uname|cut -d' ' -f1-8
    ALERT="               OneFS version is mixed                "; PRINT_ALERT
  fi
fi

CATEGORY="basic"; BODY="OneFS Version Change from messages file"
if [[ $RUN_OR_NOT -eq 1 ]]; then
  CMD="grep \": Isilon OneFS v\" ${CLU_ALL_LOG_MSG} > ${TEMP_FILE_2}"; EXEC_CMD
  CMD="grep \": Isilon OneFS v\" ${TEMP_FILE_2}|awk '{p1=index(\$0,\"Isilon OneFS\");p2=index(\$0,\"(RELEASE)\");u=substr(\$0,p1,p2-p1+9);print u}'|sort|uniq -c|sort -t\"_\" -n -k2 -k3 -k4 -k5|tee ${TEMP_FILE}"; EXEC_CMD_ONLY
  ONEFS_VERSION_HISTORY=`cat ${TEMP_FILE}|awk '{print $4}'`
  $ECHO ""
  ALREADY_PRINTED=0
  for ONEFS_VERSION_HISTORY_EACH in ${ONEFS_VERSION_HISTORY}
  do
    MAJOR_VERSION=`echo ${ONEFS_VERSION_HISTORY_EACH}|cut -d\. -f1`
    if [[ $MAJOR_VERSION = "v4" || $MAJOR_VERSION = "v5" ]]; then
      if [[ $ALREADY_PRINTED -eq 0 ]]; then
        $ECHO "Skipping Each Version starting date against OneFS v4.X and v5.X\n"
        ALREADY_PRINTED=1
      fi
    else
      $ECHO "First message of Version [ ${ONEFS_VERSION_HISTORY_EACH} ]"
      grep ${ONEFS_VERSION_HISTORY_EACH} ${TEMP_FILE_2}|grep "....-..-..T"|sort -t: -k2|head -1
    fi
  done
  rm -f ${TEMP_FILE}
  rm -f ${TEMP_FILE_2}
fi

CATEGORY="basic"; BODY="efs.gmp.group"
CMD="cat ${IN_DIR}/${CLUSTER_NODE_FIRST}/efs.gmp.group"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `cksum ${IN_DIR}/${CLUSTER_NODE_FIRST}/efs.gmp.group|awk '{print $1,$2}'|sort|uniq|wc -l` -eq 1 ]]; then
    $ECHO ""
  else
    $ECHO ">>> efs.gmp.group are NOT same on each nodes"
  fi
fi

CATEGORY="cpu"; BODY="uptime"
CMD="awk '{print FILENAME,\$0}' ${CLU_ALL}/uptime | sed 's:/uptime: :g' |sed 's:${IN_DIR}/::g'|sort -t- -n -k${CLUSTER_NAME_DASH_COUNT_TEMP}"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `awk '{print FILENAME,$0}' ${CLU_ALL}/uptime | sed 's:/uptime: :g' |sed 's:${IN_DIR}/::g'|awk '{print $2}'|sort|uniq -c|wc -l` -ne 1 ]]; then
    $ECHO "\n--> Based on uptime info, Time might not be synchronized, or gathered slightly differently\n"
    CMD="grep \"load average\" ${CLU_ALL}/top|awk '{print \$11,\" from \",\$1}'|sed 's:\:last::'"; EXEC_CMD_ONLY
    $ECHO "\n  ==> In order to confirm Time sync, check timestamp on hangdump files <==\n"
    for EACH_NODE in $CLUSTER_NODE
    do
      ls -alrt $IN_DIR/$EACH_NODE/isi_hangdump.tar/isi_hangdump_[1-9]* 2>/dev/null|tail -1|awk '{print $9}'|awk '{p1=index($0,"isi_hangdump_");u=substr($0,p1+13,19);print u}' >> ${TEMP_FILE}
    done
    if [[ `cat ${TEMP_FILE} | wc -l` -eq 0 ]]; then
      $ECHO "There might be no hangdump on this cluster"
    else
      if [[ `cat ${TEMP_FILE}|awk '{print substr($0,1,16)}'|sort|uniq -c|wc -l` -eq 1 ]]; then
        $ECHO "\n    --> Time might be OK..  Above timestamp [yyyy_mm_dd_HH_MM] is same on this cluster\n"
      else
        for EACH_NODE in $CLUSTER_NODE
        do
          ls -alrt $IN_DIR/$EACH_NODE/isi_hangdump.tar/isi_hangdump_[1-9]* 2>/dev/null|tail -1|awk '{print $9}'
        done
        WARNING="Based on uptime info as well as hangdump timestamp, Time might not be synchronized"; PRINT_WARNING
      fi
    fi
    rm -f ${TEMP_FILE}
  fi
  #LOAD_1_MIN=`awk '{print FILENAME,$0}' ${CLU_ALL}/uptime | sed 's:/uptime: :g' |sed 's:${IN_DIR}/::g'|awk '{p1=index($0,"load averages");u=substr($0,p1,100);print u}'|sed 's:load averages\: ::'|awk -F, '{print $1}'|sed 's: ::g'|sed 's:^0\.::'|sed 's:\.::'|sort -n|tail -1`
  #LOAD_5_MIN=`awk '{print FILENAME,$0}' ${CLU_ALL}/uptime | sed 's:/uptime: :g' |sed 's:${IN_DIR}/::g'|awk '{p1=index($0,"load averages");u=substr($0,p1,100);print u}'|sed 's:load averages\: ::'|awk -F, '{print $2}'|sed 's: ::g'|sed 's:^0\.::'|sed 's:\.::'|sort -n|tail -1`
  #LOAD_15_MIN=`awk '{print FILENAME,$0}' ${CLU_ALL}/uptime | sed 's:/uptime: :g' |sed 's:${IN_DIR}/::g'|awk '{p1=index($0,"load averages");u=substr($0,p1,100);print u}'|sed 's:load averages\: ::'|awk -F, '{print $3}'|sed 's: ::g'|sed 's:^0\.::'|sed 's:\.::'|sort -n|tail -1`
  #if [[ $LOAD_1_MIN -ge $CPU_COUNTS_1ST_NODE ]]; then
  #  WARNING="load average over the last 1 minute is high [ `echo "scale = 2 ; $LOAD_1_MIN/100"|bc -l` ] on some node(s)"; PRINT_WARNING
  #fi
  #if [[ $LOAD_5_MIN -ge $CPU_COUNTS_1ST_NODE ]]; then
  #  WARNING="load average over the last 5 minutes is high [ `echo "scale = 2 ; $LOAD_5_MIN/100"|bc -l` ] on some node(s)"; PRINT_WARNING
  #fi
  #if [[ $LOAD_15_MIN -ge $CPU_COUNTS_1ST_NODE ]]; then
  #  WARNING="load average over the last 15 minutes is high [ `echo "scale = 2 ; $LOAD_15_MIN/100"|bc -l` ] on some node(s)"; PRINT_WARNING
  #fi
fi

CATEGORY="cpu"; BODY="CPU & RAM & load average of the system over the last 1, 5, and 15 minutes"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  $ECHO '+----------------------+---------+-----------+----------------------------------------+'
  $ECHO '|                 Node | RAM(MB) | CPU count |   load average (1, 5, 15 minutes)       '
  $ECHO '+----------------------+---------+-----------+----------------------------------------+'
  for EACH_NODE in $CLUSTER_NODE
  do
    RAM_BYTE=`grep "RAM: " ${IN_DIR}/${EACH_NODE}/isi_hw_status 2>/dev/null |awk '{print $2}'`
    ((RAM_MEGA_BYTE=RAM_BYTE/1024/1024))
    CPU_COUNT=`cat ${IN_DIR}/${EACH_NODE}/top 2>/dev/null|egrep cpu[0-9]|wc -l|awk '{print $1}'`
    if [[ ! -f ${IN_DIR}/${EACH_NODE}/top ]]; then
      CPU_COUNT="N/A"
      CPU_COUNT_100=0
    else
      ((CPU_COUNT_100=CPU_COUNT*100))
    fi
    #printf "| %20s | %7s | %9s |   " ${EACH_NODE} ${RAM_MEGA_BYTE} ${CPU_COUNT}
    printf "| %20s | %7s | %9s |   " ${EACH_NODE} "`echo ${RAM_MEGA_BYTE}|awk '{printf("%d,%03d\n",$0/1000,$0%1000);}'`" ${CPU_COUNT}
    if [[ ! -f ${IN_DIR}/${EACH_NODE}/uptime ]]; then
      $ECHO "Not Found file: ${EACH_NODE}/uptime"
    else
      EACH_LOAD_1_MIN=`cat ${IN_DIR}/${EACH_NODE}/uptime 2>/dev/null|awk '{p1=index($0,"load average");u=substr($0,p1,50);print u}'|sed 's:load averages\:::'|awk -F, '{print $1}'|sed 's: ::g'|sed 's:^0\.::'|sed 's:\.::'|sed 's:^0::'`
      EACH_LOAD_5_MIN=`cat ${IN_DIR}/${EACH_NODE}/uptime 2>/dev/null|awk '{p1=index($0,"load average");u=substr($0,p1,50);print u}'|sed 's:load averages\:::'|awk -F, '{print $2}'|sed 's: ::g'|sed 's:^0\.::'|sed 's:\.::'|sed 's:^0::'`
      EACH_LOAD_15_MIN=`cat ${IN_DIR}/${EACH_NODE}/uptime 2>/dev/null|awk '{p1=index($0,"load average");u=substr($0,p1,50);print u}'|sed 's:load averages\:::'|awk -F, '{print $3}'|sed 's: ::g'|sed 's:^0\.::'|sed 's:\.::'|sed 's:^0::'`
      if [[ $CPU_COUNT != "N/A" ]]; then
        if [[ $EACH_LOAD_1_MIN -ge $CPU_COUNT_100 || $EACH_LOAD_5_MIN -ge $CPU_COUNT_100 || $EACH_LOAD_15_MIN -ge $CPU_COUNT_100 ]]; then
          $ECHO "[1;31m\c "
          cat ${IN_DIR}/${EACH_NODE}/uptime 2>/dev/null|awk '{p1=index($0,"load average");u=substr($0,p1,50);print u}'
          $ECHO "[1;0m\c "
        else
          cat ${IN_DIR}/${EACH_NODE}/uptime 2>/dev/null|awk '{p1=index($0,"load average");u=substr($0,p1,50);print u}'
        fi
      else
        cat ${IN_DIR}/${EACH_NODE}/uptime 2>/dev/null|awk '{p1=index($0,"load average");u=substr($0,p1,50);print u}'
      fi
    fi
  done
  $ECHO '+----------------------+---------+-----------+----------------------------------------+'
fi

CATEGORY="basic"; BODY="Nodes Information"
CMD="cat $IN_DIR/nodes_info"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `awk '{id=$1;lnn=$4;if(id != lnn) print $0}' $IN_DIR/nodes_info|wc -l` -ne 1 ]]; then
    $ECHO "\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
    $ECHO "  Lists of different id and node-sequential"
    $ECHO ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
    awk '{id=$1;lnn=$4;if(id != lnn) print $0}' $IN_DIR/nodes_info
    $ECHO "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
  fi
fi

CATEGORY="basic"; BODY="Hardware (#isi_hw_status)"
CMD="awk '{print FILENAME,\$0}' ${CLU_ALL}/isi_hw_status |grep Product| sed 's:/isi_hw_status: :g' |sed 's:${IN_DIR}/::g'|sort -t\"-\" -n -k${CLUSTER_NAME_DASH_COUNT_TEMP}"; EXEC_CMD

CATEGORY="basic"; BODY="Detailed Node Information including Config & Serial"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  $ECHO '+----------------------+-----+-----+----------------+-------------------+-------------------------------------------------------+'
  $ECHO '|            Node Name | LNN |  ID |     Config     |       Serial      |                         Model'
  $ECHO '+----------------------+-----+-----+----------------+-------------------+-------------------------------------------------------+'
  for EACH_NODE in $CLUSTER_NODE
  do
    printf "|%21s |" ${EACH_NODE}
    ID_LNN_DIFF_NODE=`grep "${EACH_NODE} " ${IN_DIR}/nodes_info|awk '{id=$1;lnn=$4;if(id!=lnn) print $3'}`
    if [[ $ID_LNN_DIFF_NODE == $EACH_NODE ]]; then
      $ECHO "[1;31m\c "
      printf " %3s " `grep "${EACH_NODE} " ${IN_DIR}/nodes_info 2>/dev/null| awk '{print $4}'`
      $ECHO "[1;0m\c "
      printf "|" 
      $ECHO "[1;31m\c "
      printf " %3s " `grep "${EACH_NODE} " ${IN_DIR}/nodes_info 2>/dev/null| awk '{print $1}'`
      $ECHO "[1;0m\c "
    else
      printf " %3s " `grep "${EACH_NODE} " ${IN_DIR}/nodes_info 2>/dev/null| awk '{print $4}'`
      printf "|" 
      printf " %3s " `grep "${EACH_NODE} " ${IN_DIR}/nodes_info 2>/dev/null| awk '{print $1}'`
    fi
    printf "| %14s " "`grep Config: ${IN_DIR}/${EACH_NODE}/isi_hw_status 2>/dev/null|cut -d: -f2|sed 's: ::'`"
    printf "| %17s " "`grep SerNo: ${IN_DIR}/${EACH_NODE}/isi_hw_status 2>/dev/null|cut -d: -f2|sed 's: ::'`"
    printf "| %s\n" "`grep Product: ${IN_DIR}/${EACH_NODE}/isi_hw_status 2>/dev/null|cut -d: -f2`"
  done
  $ECHO '+----------------------+-----+-----+----------------+-------------------+-------------------------------------------------------+'
fi

CATEGORY="network"; BODY="MTU external"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `grep mtu ${CLU_ALL}/ifconfig|grep "<UP"|egrep -v "ib[0-9]|lo[0-9]"|awk '{print $6}'|sort|uniq|wc -l` -eq 1 ]]; then
    CMD="grep mtu ${CLU_ALL}/ifconfig|grep \"<UP\"|egrep -v \"ib[0-9]|lo[0-9]\"|head -1"; EXEC_CMD_ONLY
  else
    for EACH_NODE in $CLUSTER_NODE
    do
      for I in cxgb0 cxgb1 cxgb2 cxgb3 em0 em1 em2 em3
      do 
        if [[ -f ${IN_DIR}/${EACH_NODE}/ifconfig && `grep "^${I}:" ${IN_DIR}/${EACH_NODE}/ifconfig |wc -l` -eq 0 ]]; then
          continue
        fi
        for J in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
        do 
          if [[ -f ${IN_DIR}/${EACH_NODE}/ifconfig ]]; then
            if [[ `$GNU_GREP -A${J} "^${I}:" ${IN_DIR}/${EACH_NODE}/ifconfig | grep "status: "|wc -l` -eq 1 ]]; then
              STATUS_RESULT=`$GNU_GREP -A${J} "^${I}:" ${IN_DIR}/${EACH_NODE}/ifconfig | tail -1`
              if [[ `$ECHO $STATUS_RESULT | grep "status: active" | wc -l` -eq 1 ]]; then
                $ECHO "${EACH_NODE} `$GNU_GREP "^${I}:" ${IN_DIR}/${EACH_NODE}/ifconfig` : active" >> ${TEMP_FILE}
              elif [[ `$ECHO $STATUS_RESULT | grep "status: no carrier" | wc -l` -eq 1 ]]; then
                $ECHO "${EACH_NODE} `$GNU_GREP "^${I}:" ${IN_DIR}/${EACH_NODE}/ifconfig` : no carrier" >> ${TEMP_FILE}
              fi
              break
            fi
          fi
        done
      done
    done
    #grep "active" ${TEMP_FILE} | awk '{print $7}'|sort|uniq
    if [[ `grep "active" ${TEMP_FILE} | awk '{print $7}'|sort|uniq|wc -l` -ne 1 ]]; then
      #CMD="grep mtu ${CLU_ALL}/ifconfig|grep \"<UP\"|egrep -v \"ib[0-9]|lo[0-9]\""; EXEC_CMD_ONLY
      cat ${TEMP_FILE} | grep "active"
      WARNING="        External Network MTU values are mixed        "; PRINT_WARNING
      $ECHO "\n   However, if above interfaces are using different network segment, it might be no problem"
    else
      cat ${TEMP_FILE} | grep "active"|head -1
    fi
  fi
  rm -f ${TEMP_FILE}
fi

CATEGORY="network"; BODY="MTU IB"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `grep mtu ${CLU_ALL}/ifconfig|grep "<UP"|egrep "ib[0-9]"|awk '{print $6}'|sort|uniq|wc -l` -eq 1 ]]; then
    CMD="grep mtu ${CLU_ALL}/ifconfig|grep \"<UP\"|egrep \"ib[0-9]\"|head -1"; EXEC_CMD_ONLY
  else
    CMD="grep mtu ${CLU_ALL}/ifconfig|grep \"<UP\"|egrep \"ib[0-9]\""; EXEC_CMD_ONLY
  fi
fi

CATEGORY="core"; BODY="Finding core dump files"
CMD="egrep \"core.gz$|core$\" ${CLU_ALL}/varcrash_ls|sort -k9"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  $ECHO ""
  CMD="grep \"core dumped\" ${CLU_ALL_LOG_MSG}|awk '{print \$7,\$10,\$12,\$13,\$14,\$15}'|egrep \"exited signal|exited on signal\"|sort|uniq -c|sort"; EXEC_CMD_ONLY
  $ECHO "\n-----------------------------------------------------------------------"
  $ECHO "  Recent 3 days Application core dumps"
  $ECHO "-----------------------------------------------------------------------"
  CMD="grep \"core dumped\" ${CLU_ALL_LOG_MSG}|egrep \"${DATE_LOG_GATHERED_FULL}|${DATE_LOG_GATHERED_FULL_1DAY_AGO}|${DATE_LOG_GATHERED_FULL_2DAY_AGO}|${DATE_LOG_GATHERED_FULL_3DAY_AGO}\"|awk '{print \$7,\$10,\$12,\$13,\$14,\$15}'|egrep \"exited signal|exited on signal\"|sort|uniq -c|sort"; EXEC_CMD_ONLY
  CORE_RECENT_COUNT=`grep "core dumped" ${CLU_ALL_LOG_MSG}|egrep "${DATE_LOG_GATHERED_FULL}|${DATE_LOG_GATHERED_FULL_1DAY_AGO}|${DATE_LOG_GATHERED_FULL_2DAY_AGO}|${DATE_LOG_GATHERED_FULL_3DAY_AGO}"|awk '{print $7,$10,$12,$13,$14,$15}'|egrep "exited signal|exited on signal"|wc -l`
  $ECHO "-----------------------------------------------------------------------\n"

  if [[ $RUNNING_ON_SOLARIS -eq 1 ]]; then
    if [[ -f /usr/bin/parse_stacks ]]; then
      PARSE_STACKS="/usr/bin/parse_stacks"
    elif [[ -f /usr/local/bin/parse_stacks ]]; then
      PARSE_STACKS="/usr/local/bin/parse_stacks"
    fi
  else
    #if [[ -f /usr/local/bin/parse_stacks2 ]]; then
    #  PARSE_STACKS="/usr/local/bin/parse_stacks2"
    #elif [[ -f /usr/bin/parse_stacks2 ]]; then
    #  PARSE_STACKS="/usr/bin/parse_stacks2"
    #fi
    if [[ -f /usr/local/bin/parse_stacks ]]; then
      PARSE_STACKS="/usr/local/bin/parse_stacks"
    elif [[ -f /usr/bin/parse_stacks ]]; then
      PARSE_STACKS="/usr/bin/parse_stacks"
    fi
  fi

  if [[ $NO_STACK -ne 1 && $CORE_RECENT_COUNT -ge 1 ]]; then
    $ECHO "\n---------------------------------------------------------------------------"
    $ECHO "  Check stack through parse_stacks, Recent 3 days(Limit 10) App core dumps"
    $ECHO "---------------------------------------------------------------------------"
    CMD="cat ${CLU_ALL_LOG_MSG}|grep \"core dumped\"|egrep \"exited signal|exited on signal\"|egrep \"${DATE_LOG_GATHERED_FULL}|${DATE_LOG_GATHERED_FULL_1DAY_AGO}|${DATE_LOG_GATHERED_FULL_2DAY_AGO}|${DATE_LOG_GATHERED_FULL_3DAY_AGO}\"|sort|tail -10 > ${TEMP_FILE}"; EXEC_CMD_ONLY
    ## CMD="cat ${CLU_ALL_LOG_MSG} | egrep \"${DATE_LOG_GATHERED_FULL}|${DATE_LOG_GATHERED_FULL_1DAY_AGO}|${DATE_LOG_GATHERED_FULL_2DAY_AGO}|${DATE_LOG_GATHERED_FULL_3DAY_AGO}\" > ${TEMP_FILE}"; EXEC_CMD_ONLY

    if [[ -s ${TEMP_FILE} ]]; then
      exec 3< ${TEMP_FILE}
      while true
      do
        read -u3 LineStr
        if [[ ${LineStr}"X" = "X" ]]; then
           break
        fi
        if [[ `$GNU_GREP -B4 "${LineStr}" ${CLU_ALL_LOG_MSG}|grep "Stack not recorded"|wc -l` -ne 0 ]]; then
          CMD="$GNU_GREP -B4 \"${LineStr}\" ${CLU_ALL_LOG_MSG}"; EXEC_CMD_ONLY
          $ECHO "[1;41m--> Stack not recorded <--[0m\n"
        else  
          $GNU_GREP -B50 "${LineStr}" ${CLU_ALL_LOG_MSG} | grep -v "last message repeated" >> ${TEMP_FILE_2}
        fi
      done
      if [[ $BUGZ_COOKIE_EXIST -eq 1 && $NO_STACK -ne 1 ]]; then
        if [[ -f ${TEMP_FILE_2} ]]; then
          $PARSE_STACKS ${TEMP_FILE_2}
        fi
      fi
    fi
    ## $PARSE_STACKS ${TEMP_FILE}
    rm -f ${TEMP_FILE}
    rm -f ${TEMP_FILE_2}
  fi
fi

CATEGORY="hangdump"; BODY="Finding hangdump files"
CMD="ls -alrt ${IN_DIR}/${CLUSTER_NODE_FIRST}/isi_hangdump.tar/isi_hangdump*"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  $ECHO "\n-----------------------------------------------------------------------"
  $ECHO "  Lock timeout : sorted by date"
  $ECHO "-----------------------------------------------------------------------"
  CMD="grep \"efs.lin.lock.initiator.oldest_waiter\" ${CLU_ALL_LOG_MSG}|sort -t: -k2|tail -15"; EXEC_CMD_ONLY
  $ECHO "\n-----------------------------------------------------------------------"
  $ECHO "  Recent 3 days Lock timeout : sorted by waiter timeout seconds"
  $ECHO "-----------------------------------------------------------------------"
  CMD="grep \"efs.lin.lock.initiator.oldest_waiter\" ${CLU_ALL_LOG_MSG}|egrep \"${DATE_LOG_GATHERED_FULL}|${DATE_LOG_GATHERED_FULL_1DAY_AGO}|${DATE_LOG_GATHERED_FULL_2DAY_AGO}|${DATE_LOG_GATHERED_FULL_3DAY_AGO}\"|sort -n -k7|tail -15"; EXEC_CMD_ONLY
fi

CATEGORY="panic"; BODY="minidump (Panic dump)"
CMD="ls -alhrt ${CLU_ALL}/minidumps.tar/vmcore*"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `grep "savecore: no dump, not enough free space on device" ${CLU_LATEST_MSG}|wc -l` -ne 0 ]]; then
    $ECHO ""
    CMD="grep \"savecore: no dump, not enough free space on device\" ${CLU_LATEST_MSG}"; EXEC_CMD_ONLY
    ALERT="There might be unsaved dump(s) on node(s), you would be able to get it using following command"; PRINT_ALERT
    $ECHO "-----------------------------------------------------------------------"
    $ECHO "  1. # mkdir -p /ifs/data/temp.dumpdir"
    $ECHO "  2. # savecore -kvz /ifs/data/temp.dumpdir /dev/<dump_device_name>"
    $ECHO "-----------------------------------------------------------------------\n"
    
    WARNING="Then, how to know what dump_device we should use....."; PRINT_WARNING
    for UNSAVED_NODE in `grep -l "savecore: no dump, not enough free space on device" ${CLU_LATEST_MSG}`
    do
      $ECHO "-------------\nmessages file having \"not enough free space on device\" : [ $UNSAVED_NODE ]\n" 
      #CMD="egrep \"panic @|savecore: no dump|Dumping on device\" $UNSAVED_NODE"; EXEC_CMD_ONLY
      CMD="egrep \"panic @|savecore: no dump|Found minidump\" $UNSAVED_NODE"; EXEC_CMD_ONLY
      $ECHO "\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
      $ECHO "  So, you might be able to use device followed by \"Found minidump\"" 
      $ECHO "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n"
    done
  fi

  if [[ $IS_ONEFS_version7 -eq 1 ]]; then
    if [[ `grep "savecore: no dump, not enough free space on device" ${CLU_ALL_LOG}/isi_sys_bootdisk.log |wc -l` -ne 0 ]]; then
      $ECHO ""
      CMD="grep \"savecore: no dump, not enough free space on device\" ${CLU_ALL_LOG}/isi_sys_bootdisk.log"; EXEC_CMD_ONLY
      ALERT="There might be unsaved dump(s) on node(s), you would be able to get it using following command"; PRINT_ALERT
      $ECHO "-----------------------------------------------------------------------"
      $ECHO "  1. # mkdir -p /ifs/data/temp.dumpdir"
      $ECHO "  2. # savecore -kvz /ifs/data/temp.dumpdir /dev/<dump_device_name>"
      $ECHO "-----------------------------------------------------------------------\n"
      
      for UNSAVED_NODE in `grep -l "savecore: no dump, not enough free space on device" ${CLU_ALL_LOG}/isi_sys_bootdisk.log` 
      do
        $ECHO "-------------\nmessages file having \"not enough free space on device\" : [ $UNSAVED_NODE ]\n" 
        CMD="egrep \"no dump, not enough free space on device|/sbin/savecore -v /var/crash /dev/\" $UNSAVED_NODE|grep -v \"returned: 0\""; EXEC_CMD_ONLY
        $ECHO "\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
        $ECHO "  So, you might be able to use device displayed before \"not enough free space on device\" on savecore command" 
        $ECHO "  For example: "
        $ECHO "  # mkdir /ifs/data/temp.dumpdir ; savecore -kvz /ifs/data/temp.dumpdir `grep "/sbin/savecore -v /var/crash /dev/" $UNSAVED_NODE | grep "returned: 1"|tail -1|awk '{print $7}'` "
        $ECHO ""
        $ECHO "  or, much easier way is:"
        $ECHO "  use \"isi_savecore\" command after logon to the panicked node like below" 
        $ECHO "  # isi_savecore -d /ifs/data/temp.dumpdir --save"
        $ECHO "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n"
      done
    fi
  fi
fi

CATEGORY="panic"; BODY="Panic Messages from /var/log/messages all files"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  $ECHO "\n-----------------------------------------------------------------"
  #$ECHO " On Jan-9-2013, added parse_stacks feature against panic stack"
  $ECHO " On Nov-25-2013, added parse_stacks2 feature against panic stack"
  $ECHO "-----------------------------------------------------------------\n"
  
  if [[ $RUNNING_ON_SOLARIS -eq 1 ]]; then
    # on OneFS v5.X, panic stack is different from OneFS v6.X
    # so, this script will use both panics_class() and us_stack_class() in parse_stacks tool
    if [[ $IS_ONEFS_version5 -eq 1 ]]; then
      if [[ -f /usr/bin/parse_stacks ]]; then
        PARSE_STACKS="/usr/bin/parse_stacks"
      elif [[ -f /usr/local/bin/parse_stacks ]]; then
        PARSE_STACKS="/usr/local/bin/parse_stacks"
      fi
    # in OneFS v6.X, this script will use only panics_class() in parse_stacks tool
    # so it will use modified parse_stacks.panic tool in following location
    else
      if [[ -f /home/tpark/parse_stacks.panic ]]; then
        PARSE_STACKS="/home/tpark/parse_stacks.panic"
      elif [[ -f /usr/local/bin/parse_stacks.panic ]]; then
        PARSE_STACKS="/usr/local/bin/parse_stacks.panic"
      elif [[ -f /usr/bin/parse_stacks.panic ]]; then
        PARSE_STACKS="/usr/bin/parse_stacks.panic"
      elif [[ -f /usr/local/bin/parse_stacks ]]; then
        PARSE_STACKS="/usr/local/bin/parse_stacks"
      else
        $ECHO "Unfortunately, parse_stacks tool NOT found in /usr/lcoal/bin or /usr/bin directory"
        PARSE_STACKS=""
        NOT_FOUND_PARSE_STACKS=1
      fi
    fi
  else
    # on OneFS v5.X, panic stack is different from OneFS v6.X
    # so, this script will use both panics_class() and us_stack_class() in parse_stacks tool
    if [[ $IS_ONEFS_version5 -eq 1 ]]; then
      #if [[ -f /usr/bin/parse_stacks2 ]]; then
      #  PARSE_STACKS="/usr/bin/parse_stacks2"
      #elif [[ -f /usr/local/bin/parse_stacks2 ]]; then
      #  PARSE_STACKS="/usr/local/bin/parse_stacks2"
      #fi
      if [[ -f /usr/bin/parse_stacks ]]; then
        PARSE_STACKS="/usr/bin/parse_stacks"
      elif [[ -f /usr/local/bin/parse_stacks ]]; then
        PARSE_STACKS="/usr/local/bin/parse_stacks"
      fi
    # in OneFS v6.X, this script will use only panics_class() in parse_stacks tool
    # so it will use modified parse_stacks.panic tool in following location
    else
      #if [[ -f /home/tpark/parse_stacks2.panic ]]; then
      #  PARSE_STACKS="/home/tpark/parse_stacks2.panic"
      #elif [[ -f /usr/local/bin/parse_stacks2.panic ]]; then
      #  PARSE_STACKS="/usr/local/bin/parse_stacks2.panic"
      #elif [[ -f /usr/bin/parse_stacks2.panic ]]; then
      #  PARSE_STACKS="/usr/bin/parse_stacks2.panic"
      #elif [[ -f /usr/local/bin/parse_stacks2 ]]; then
      #  PARSE_STACKS="/usr/local/bin/parse_stacks2"
      #else
      #  $ECHO "Unfortunately, parse_stacks2 tool NOT found in /usr/lcoal/bin or /usr/bin directory"
      if [[ -f /home/tpark/parse_stacks.panic ]]; then
        PARSE_STACKS="/home/tpark/parse_stacks.panic"
      elif [[ -f /usr/local/bin/parse_stacks.panic ]]; then
        PARSE_STACKS="/usr/local/bin/parse_stacks.panic"
      elif [[ -f /usr/bin/parse_stacks.panic ]]; then
        PARSE_STACKS="/usr/bin/parse_stacks.panic"
      elif [[ -f /usr/local/bin/parse_stacks ]]; then
        PARSE_STACKS="/usr/local/bin/parse_stacks"
      else
        $ECHO "Unfortunately, parse_stacks tool NOT found in /usr/lcoal/bin or /usr/bin directory"
        PARSE_STACKS=""
        NOT_FOUND_PARSE_STACKS=1
      fi
    fi
  fi

  CMD="grep \"panic @\" ${CLU_ALL_LOG_MSG} > ${TEMP_FILE}"; EXEC_CMD_ONLY
  echo "# grep \"panic @\" ${TEMP_FILE}|$GNU_GREP -o \"panic @ time [[:xdigit:]]\{10\}.[[:xdigit:]]\{3\}\"|sort|uniq|cut -d' ' -f4"
  PANIC_TIME=`grep "panic @" ${TEMP_FILE}|$GNU_GREP -o "panic @ time [[:xdigit:]]\{10\}.[[:xdigit:]]\{3\}"|sort|uniq|cut -d' ' -f4`

  echo "TimeZone is [$TIMEZONE_ENV] : [$TIMEZONE]"
  PRINT_ONCE=1
  for PT in ${PANIC_TIME}
  do
    if [[ $PRINT_ONCE -eq 1 ]]; then
      echo '+--------------------------+----------------+--------------------------------------+' | tee -a ${TEMP_PANIC_OUTPUT}
      echo '|     Panic Local Time     |  Since Epoch   |  Panic String & Node [messages file]'   | tee -a ${TEMP_PANIC_OUTPUT}
      echo '+--------------------------+----------------+--------------------------------------+' | tee -a ${TEMP_PANIC_OUTPUT}
      PRINT_ONCE=0
    fi
    LOCAL_TIME=`env TZ=${TIMEZONE_ENV} perl -e "print scalar localtime($PT)"`
    PANIC_STRING=`grep "panic @ time ${PT}" ${TEMP_FILE}|grep "/boot/kernel.amd64/kernel"|sed "s:${IN_DIR}/::"|sed "s:/varlog.tar/log/:\::"`

    if [[ ${PANIC_STRING}_x = "_x" ]]; then
      PANIC_STRING=`grep "panic @ time ${PT}" ${TEMP_FILE}|sed "s:${IN_DIR}::"|sed "s:/varlog.tar/log/:\::"|sed "s:panic @ time ${PT}\:::"`
    fi
    echo "| $LOCAL_TIME | $PT | ${PANIC_STRING}"                                                  | tee -a ${TEMP_PANIC_OUTPUT}
    echo '+--------------------------+----------------+---------------------------------------'   | tee -a ${TEMP_PANIC_OUTPUT}

    #------- logic of parse_stacks.panic -------#
    PANIC_NODE_NAME=`echo $PANIC_STRING|cut -d: -f1|sed 's:/::g'`
    #echo "PANIC_NODE_NAME : [$PANIC_NODE_NAME]"
    PANIC_MESSAGES_NAME=`echo $PANIC_STRING|cut -d: -f2`
    #echo "PANIC_MESSAGES_NAME : [$PANIC_MESSAGES_NAME]"
    
    ##-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------##    
    ## added the following IF clause, just for "lock type ufs: EXCL (count 1) by thread 0xffffff0040d00000 (pid 4663) (proc isi_hdfs_d) with 24 pendingpanic @ time 1362691640.082" case ##
    ##-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------##    
    if [[ `grep "pendingpanic @ time" ${TEMP_FILE} | wc -l` -ne 0 ]]; then
      #echo "=========> test in IF <==============="
      #echo "$GNU_EGREP -A50 \"^panic @ time ${PT}|pendingpanic @ time ${PT}\" ${IN_DIR}/${PANIC_NODE_NAME}/varlog.tar/log/${PANIC_MESSAGES_NAME}"
      #$GNU_EGREP -A50 "^panic @ time ${PT}|pendingpanic @ time ${PT}" ${IN_DIR}/${PANIC_NODE_NAME}/varlog.tar/log/${PANIC_MESSAGES_NAME}
      #echo "$GNU_EGREP -A50 \"^panic @ time ${PT}|pendingpanic @ time ${PT}\" ${IN_DIR}/${PANIC_NODE_NAME}/varlog.tar/log/${PANIC_MESSAGES_NAME}|egrep -v \"....-..-..T..:..:..\" "
      #GNU_EGREP -A50 "^panic @ time ${PT}|pendingpanic @ time ${PT}" ${IN_DIR}/${PANIC_NODE_NAME}/varlog.tar/log/${PANIC_MESSAGES_NAME}|egrep -v "....-..-..T..:..:.." 

      ##--- 1. remove system call part 'ia32_syscall' ---###
      $GNU_EGREP -A50 "^panic @ time ${PT}|pendingpanic @ time ${PT}" ${IN_DIR}/${PANIC_NODE_NAME}/varlog.tar/log/${PANIC_MESSAGES_NAME}|egrep -v "....-..-..T..:..:..|ia32_syscall" > /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_TEMP_
      ##--- 2. NOT remove system call part 'ia32_syscall' ; result was nothing, because of differece between 6.5.X and 7.X ---###
      #$GNU_EGREP -A50 "^panic @ time ${PT}|pendingpanic @ time ${PT}" ${IN_DIR}/${PANIC_NODE_NAME}/varlog.tar/log/${PANIC_MESSAGES_NAME}|egrep -v "....-..-..T..:..:.." > /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_TEMP_

      cat /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_TEMP_ | sed 's:pendingpanic @ time:pending\
panic @ time:' > /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_
      #echo "=========> check file start <==============="
      #echo "cat /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_TEMP_"
      #cat /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_TEMP_
      #echo "cat /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_"
      #cat /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_
      #echo "=========> check file end <==============="
    else
      if [[ `grep "^panic @ time ${PT}" ${IN_DIR}/${PANIC_NODE_NAME}/varlog.tar/log/${PANIC_MESSAGES_NAME} 2>/dev/null|wc -l` -eq 0 ]]; then
        $ECHO "[1;41m -- Not Found: panic stack starting with \"^panic @\" -- [0m"
        $GNU_GREP -A50 "panic @ time ${PT}" ${IN_DIR}/${PANIC_NODE_NAME}/varlog.tar/log/${PANIC_MESSAGES_NAME}|cut -d' ' -f5-100 > /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_
      else
        $GNU_GREP -A50 "^panic @ time ${PT}" ${IN_DIR}/${PANIC_NODE_NAME}/varlog.tar/log/${PANIC_MESSAGES_NAME} > /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_
      fi
    fi
    #echo "$GNU_GREP -A50 \"^panic @ time ${PT}\" ${IN_DIR}/${PANIC_NODE_NAME}/varlog.tar/log/${PANIC_MESSAGES_NAME} > /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_"
    #cat /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_
    #ls -al /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_
    #echo "=========> $PARSE_STACKS /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_"
    if [[ $BUGZ_COOKIE_EXIST -eq 1 && $NO_STACK -ne 1 ]]; then
      $PARSE_STACKS /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_
      echo '+--------------------------+----------------+---------------------------------------'
    fi
    rm -f /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_TEMP_
    rm -f /${TEMP_DIR}/_PANIC_${PT}_${PANIC_NODE_NAME}_${PANIC_MESSAGES_NAME}_
    #------- logic of parse_stacks.panic -------#
  done
  #if [[ $BUGZ_COOKIE_EXIST -eq 0 ]]; then
  #  echo '+--------------------------+----------------+---------------------------------------'
  #fi
  rm -f ${TEMP_FILE}
fi

CATEGORY="etc"; BODY="DWT(Device Work Thread) Processes (>500 and >1000)"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  CMD="egrep \"There are now.*DWT threads\" ${CLU_LATEST_MSG} > ${TEMP_FILE}"; EXEC_CMD_ONLY
  $ECHO "[ DWT Number 500~999 ]"
  WC_COUNT=`egrep "There are now ... DWT threads" ${TEMP_FILE}|wc -l`
  CMD="egrep \"There are now ... DWT threads\" ${TEMP_FILE}|wc -l"; EXEC_CMD_ONLY
  if [[ $WC_COUNT -ne 0 ]]; then
    $ECHO ""
    CMD="egrep \"There are now ... DWT threads\" ${TEMP_FILE}|sort -t: -k2|head -3"; EXEC_CMD_ONLY
    if [[ $WC_COUNT -gt 6 ]]; then
      TAIL_COUNT=3
      $ECHO "\n...< might be snipped if count is over 6 >...\n"
      CMD="egrep \"There are now ... DWT threads\" ${TEMP_FILE}|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
    elif [[ $WC_COUNT -gt 3 ]]; then
      $ECHO ""
      ((TAIL_COUNT=WC_COUNT-3))
      CMD="egrep \"There are now ... DWT threads\" ${TEMP_FILE}|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
    fi
  fi
  $ECHO "\n[ DWT Number >1000 ]"
  WC_COUNT=`egrep "There are now .... DWT threads" ${TEMP_FILE}|wc -l`
  CMD="egrep \"There are now .... DWT threads\" ${TEMP_FILE}|wc -l"; EXEC_CMD_ONLY
  if [[ $WC_COUNT -ne 0 ]]; then
    $ECHO ""
    CMD="egrep \"There are now .... DWT threads\" ${TEMP_FILE}|sort -t: -k2|head -3"; EXEC_CMD_ONLY
    if [[ $WC_COUNT -gt 6 ]]; then
      TAIL_COUNT=3
      $ECHO "\n...< might be snipped if count is over 6 >...\n"
      CMD="egrep \"There are now .... DWT threads\" ${TEMP_FILE}|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
    elif [[ $WC_COUNT -gt 3 ]]; then
      $ECHO ""
      ((TAIL_COUNT=WC_COUNT-3))
      CMD="egrep \"There are now .... DWT threads\" ${TEMP_FILE}|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
    fi
  fi
  rm -f ${TEMP_FILE}
fi

CATEGORY="lock"; BODY="Outstanding Locks Check (lk_initiator law)"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  ( for C in $CLUSTER_NODE
  do $ECHO "[1;33m[ $C ][0m"
    if [[ -f ${IN_DIR}/${C}/varlog.tar/log/vmlog.0 ]]; then
      if [[ `egrep "lk_initiator law" ${IN_DIR}/$C/varlog.tar/log/vmlog.0 ${IN_DIR}/$C/varlog.tar/log/vmlog|wc -l` -eq 0 ]]; then
        continue
      fi
      if [[ `egrep " ${TIMEZONE} |lk_initiator law" ${IN_DIR}/$C/varlog.tar/log/vmlog.0 ${IN_DIR}/$C/varlog.tar/log/vmlog|tail -4|wc -l` -eq 4 ]]; then
        test `egrep " ${TIMEZONE} |lk_initiator law" ${IN_DIR}/$C/varlog.tar/log/vmlog.0 ${IN_DIR}/$C/varlog.tar/log/vmlog|tail -4|grep -v "lk_initiator law     0"|wc -l` -ne 2 && \
        egrep " ${TIMEZONE} |lk_initiator law" ${IN_DIR}/$C/varlog.tar/log/vmlog.0 ${IN_DIR}/$C/varlog.tar/log/vmlog|tail -4|sed "s:${IN_DIR}/$C/varlog.tar/log/vmlog\:::"|sed "s:${IN_DIR}/$C/varlog.tar/log/vmlog.0\:::"
      else
        test `egrep " ${TIMEZONE} |lk_initiator law" ${IN_DIR}/$C/varlog.tar/log/vmlog.0 ${IN_DIR}/$C/varlog.tar/log/vmlog|tail -2|grep -v "lk_initiator law     0"|wc -l` -ne 1 && \
        egrep " ${TIMEZONE} |lk_initiator law" ${IN_DIR}/$C/varlog.tar/log/vmlog.0 ${IN_DIR}/$C/varlog.tar/log/vmlog|tail -2|sed "s:${IN_DIR}/$C/varlog.tar/log/vmlog\:::"sed "s:${IN_DIR}/$C/varlog.tar/log/vmlog.0\:::"
      fi
    else
      if [[ `egrep " ${TIMEZONE} |lk_initiator law" ${IN_DIR}/$C/varlog.tar/log/vmlog|tail -4|wc -l` -eq 4 ]]; then
        if [[ `egrep "lk_initiator law" ${IN_DIR}/$C/varlog.tar/log/vmlog|tail -2|wc -l` -eq 2 ]]; then
          test `egrep " ${TIMEZONE} |lk_initiator law" ${IN_DIR}/$C/varlog.tar/log/vmlog|tail -4|grep -v "lk_initiator law     0"|wc -l` -ne 2 && \
          egrep " ${TIMEZONE} |lk_initiator law" ${IN_DIR}/$C/varlog.tar/log/vmlog|tail -4|sed "s:${IN_DIR}/$C/varlog.tar/log/vmlog\:::"
        fi
      else
        if [[ `egrep "lk_initiator law" ${IN_DIR}/$C/varlog.tar/log/vmlog|tail -1|wc -l` -eq 1 ]]; then
          test `egrep " ${TIMEZONE} |lk_initiator law" ${IN_DIR}/$C/varlog.tar/log/vmlog|tail -2|grep -v "lk_initiator law     0"|wc -l` -ne 1 && \
          egrep " ${TIMEZONE} |lk_initiator law" ${IN_DIR}/$C/varlog.tar/log/vmlog|tail -2|sed "s:${IN_DIR}/$C/varlog.tar/log/vmlog\:::"
        fi
      fi
    fi
  done )
  $ECHO "\n::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
  $ECHO "  When you see any large number (e.g. over 30k), in third field like, which is \"InUse\""
  $ECHO "  It would cause cluster-wide hang once node panic occurs or reboot node manually."
  $ECHO ""
  $ECHO "  Tue Jul 24 12:10:00 SGT 2012"
  $ECHO "  lk_initiator law 45161 22581K       - 965953763  8192"
  $ECHO "                   ^^^^^"
  $ECHO "  For more details, please refer to Bug 84114 and Bug 96255."
  $ECHO "::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
fi

CATEGORY="cpu"; BODY="top (CPU High)"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  for EACH_NODE in $CLUSTER_NODE
  do
    BODY="${EACH_NODE} : top (CPU High)"; PRINT_HEAD_LOOP
    CMD="cat ${IN_DIR}/${EACH_NODE}/top|head -20|grep -v \"^$\""; EXEC_CMD_ONLY
  done
fi

CATEGORY="runq"; BODY="RUNQ info from vmlog"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  for EACH_NODE in $CLUSTER_NODE
  do
    BODY="${EACH_NODE} : RUNQ info from vmlog"; PRINT_HEAD_LOOP
    if [[ -f ${IN_DIR}/${EACH_NODE}/varlog.tar/log/vmlog.0 ]]; then
        grep RUNQ ${IN_DIR}/${EACH_NODE}/varlog.tar/log/vmlog.0 ${IN_DIR}/${EACH_NODE}/varlog.tar/log/vmlog |tail -3
    else
        grep RUNQ ${IN_DIR}/${EACH_NODE}/varlog.tar/log/vmlog |tail -2
    fi
  done
fi

CATEGORY="basic"; BODY="${CLUSTER_NODE_FIRST} : # isi alerts (# isi events)"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `cksum ${CLU_ALL}/isi_alerts|awk '{print $1}'|sort|uniq|wc -l` -eq 1 ]]; then
    $ECHO ">>> isi alerts are same on each nodes\n"
    CMD="cat ${IN_DIR}/${CLUSTER_NODE_FIRST}/isi_alerts"; EXEC_CMD_ONLY
  else
    CMD="cksum ${CLU_ALL}/isi_alerts|awk '{print \$1}'|sort|uniq|wc -l"; EXEC_CMD_ONLY
    $ECHO "<<< <<< isi alerts are NOT same on each nodes"
    $ECHO ">>>   Please Check them Manually !!!     <<<\n"
    CMD="cksum ${CLU_ALL}/isi_alerts"; EXEC_CMD_ONLY
    CMD="cat ${IN_DIR}/${CLUSTER_NODE_FIRST}/isi_alerts"; EXEC_CMD_ONLY
  fi
fi

CATEGORY="basic"; BODY="${CLUSTER_NODE_FIRST} : # isi status"
CMD="cat ${IN_DIR}/${CLUSTER_NODE_FIRST}/isi_status"; EXEC_CMD

CATEGORY="perf"; BODY="# isi statistics system -d --nodes : ONLY(After 6.X.X)"
CMD="cat ${IN_DIR}/local/isi_statistics"; EXEC_CMD

CATEGORY="snapshot"; BODY="Snapshot IQ error (EINVAL EIO)"
CMD="egrep \"EINVAL|EIO\" ${CLU_ALL_LOG_ISI_SNAPSHOT_D}|sort -t: -k2|wc -l"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `eval $CMD` -ne 0 ]]; then
    if [[ PREVIOUS_CURRENT_V4_V5 -eq 1 ]]; then
      CMD="egrep \"EINVAL|EIO\" ${CLU_ALL_LOG_ISI_SNAPSHOT_D}|egrep -v \"${OLD_DATE_FORMAT}\"|sort -t: -k2|tail -10"; EXEC_CMD_ONLY
    else
      CMD="egrep \"EINVAL|EIO\" ${CLU_ALL_LOG_ISI_SNAPSHOT_D}|sort -t: -k2|tail -10"; EXEC_CMD_ONLY
    fi
  fi
fi

CATEGORY="snapshot"; BODY="Snapshot IQ error (EDEADLK)"
CMD="egrep \"EDEADLK\" ${CLU_ALL_LOG_ISI_SNAPSHOT_D}|sort -t: -k2|wc -l"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `eval $CMD` -ne 0 ]]; then
    if [[ PREVIOUS_CURRENT_V4_V5 -eq 1 ]]; then
      CMD="egrep \"EDEADLK\" ${CLU_ALL_LOG_ISI_SNAPSHOT_D}|egrep -v \"${OLD_DATE_FORMAT}\"|sort -t: -k2|tail -10"; EXEC_CMD_ONLY
    else
      CMD="egrep \"EDEADLK\" ${CLU_ALL_LOG_ISI_SNAPSHOT_D}|sort -t: -k2|tail -10"; EXEC_CMD_ONLY
    fi
  fi

  if [[ $SKIP_THIS -eq 1 ]]; then
    BODY="SKIPPED THIS Part : Unknown ECCs: from isi_job_history : #isi job history -verbose -limit 0"
  else
    BODY="Unknown ECCs: from isi_job_history : #isi job history -verbose -limit 0"
    CMD="$GNU_GREP -A1 \"Unknown ECCs:\" ${IN_DIR}/local/isi_job_history"; EXEC_CMD
  fi
fi

CATEGORY="firmware"; BODY="Drive Firmware version check"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  #CMD="grep \"FW\" ${CLU_ALL_ISI_RADISH}|sed 's:is HDS:is HITACHI HDS:'|sed 's:P300-MTF:Micron P300-MTF:'|sed 's:MACH8 IOPS:MACH8_IOPS:'|sed 's:ST3: Seagate ST3:'|sed 's:ST930060 CLAR300:ST930060_CLAR300:'|sed 's:SSD 8GB-001:SSD_8GB-001:'|sed 's:ST4000NM0033-9ZM170:Seagate ST4000NM0033-9ZM170:'|sed 's:ST1000NM0033-9ZM173:Seagate ST1000NM0033-9ZM173:'|sort -k5|awk '{print \$4,\$5,\$6}'|sort|uniq -c | tee ${TEMP_FILE}"; EXEC_CMD_ONLY
  CMD="grep \"FW\" ${CLU_ALL_ISI_RADISH}|sed 's:is HDS:is HITACHI HDS:'|sed 's:P300-MTF:Micron P300-MTF:'|sed 's:MACH8 IOPS:MACH8_IOPS:'|sed 's:ST930060 CLAR300:ST930060_CLAR300:'|sed 's:SSD 8GB-001:SSD_8GB-001:'|sed 's:ST4000NM0033-9ZM170:Seagate ST4000NM0033-9ZM170:'|sed 's:ST1000NM0033-9ZM173:Seagate ST1000NM0033-9ZM173:'|sort -k5|awk '{print \$4,\$5,\$6}'|sort|uniq -c | tee ${TEMP_FILE}"; EXEC_CMD_ONLY

  #-------- Current drive and firmware comparison to latest firmware --------#
  $ECHO ""
  $ECHO "  +-------------+-----------------+----------------------+----------+----------+------------------+------------------+--------------------------+"
  $ECHO "  | Drive Count |      Vendor     |      Drive Model     | Capacity |  Profile | Current Firmware |  Latest Firmware | Firmware v1.6 included ? |"
  $ECHO "  +-------------+-----------------+----------------------+----------+----------+------------------+------------------+--------------------------+"
  
  PREV_DRIVE_MODEL=""
  while read READ_LINE
  do
    FIRMWARE_NA=0
    #FIRMWARE_15_OR_NOT=0
    FIRMWARE_16_OR_NOT=0
    DRIVE_COUNT=`echo $READ_LINE|awk '{print $1}'`
    DRIVE_VENDOR=`echo $READ_LINE|awk '{print $2}'`
    DRIVE_MODEL=`echo $READ_LINE|awk '{print $3}'`
    if [[ ${PREV_DRIVE_MODEL} != ${DRIVE_MODEL} && ${PREV_DRIVE_MODEL}"X" != "X" ]]; then
      $ECHO "  +-------------+-----------------+----------------------+----------+----------+------------------+------------------+--------------------------+"
    fi
    PREV_DRIVE_MODEL=${DRIVE_MODEL}
    DRIVE_FIRMWARE=`echo $READ_LINE|awk '{print $4}'|sed 's:FW\:::'`
  
    case ${DRIVE_MODEL} in 
      "HUA722050CLA330") # fwversions = [ "JP2OA3GB", "JP2OA3MA", "JP2OA3PA" ]
        LASTEST_FIRMWARE="JP2OA3PA"; DRIVE_CAPACITY="500 GB"; PROFILE="hdd_sata"; FIRMWARE_16_OR_NOT=1 ;;
      "HUA722010CLA330") # fwversions = [ "JP4OA3GB", "JP4OA3MA", "JP4OA3PA" ]
        LASTEST_FIRMWARE="JP4OA3PA"; DRIVE_CAPACITY="1 TB"; PROFILE="hdd_sata"; FIRMWARE_16_OR_NOT=1 ;;
      "HUA722020ALA330") # fwversions = [ "JKAOA20N", "JKAOA28A", "JKAOA3GA", "JKAOA3MA", "JKAOA3PA" ]
        LASTEST_FIRMWARE="JKAOA3PA"; DRIVE_CAPACITY="2 TB"; PROFILE="hdd_sata"; FIRMWARE_16_OR_NOT=1 ;;
      "HUA723020ALA640") # fwversions = [ "MK7OA6L0", "MK7OA8P0", "MK7OAA50" ]
        LASTEST_FIRMWARE="MK7OAA50"; DRIVE_CAPACITY="2 TB"; PROFILE="hdd_sata"; FIRMWARE_16_OR_NOT=1 ;;
      "HUA723030ALA640") # fwversions = [ "MKAOA5V0", "MKAOA6L0", "MKAOA8P0",  "MKAOAA50" ]
        LASTEST_FIRMWARE="MKAOAA50"; DRIVE_CAPACITY="3 TB"; PROFILE="hdd_sata"; FIRMWARE_16_OR_NOT=1 ;;
      "HUSSL4010ASS600") # fwversions = [ "A131", "A182" ]
        LASTEST_FIRMWARE="A182";     DRIVE_CAPACITY="100 GB"; PROFILE="ssd_sas"; FIRMWARE_16_OR_NOT=1 ;;
      "HUSSL4020ASS600") # fwversions = [ "A131", "A182" ]
        LASTEST_FIRMWARE="A182";     DRIVE_CAPACITY="200 GB"; PROFILE="ssd_sas"; FIRMWARE_16_OR_NOT=1 ;;
      "HUSSL4040ASS600") # fwversions = [ "A131", "A182" ]
        LASTEST_FIRMWARE="A182";     DRIVE_CAPACITY="400 GB"; PROFILE="ssd_sas"; FIRMWARE_16_OR_NOT=1 ;;
      "HUC109030CSS600") ### fwversions = [ "A222", "A2D0", "A350", "A440" ]
        LASTEST_FIRMWARE="A440";     DRIVE_CAPACITY="300 GB"; PROFILE="hdd_sas"; FIRMWARE_16_OR_NOT=1 ;;
      "HUC109060CSS600") ### fwversions = [ "A222", "A2D0", "A350", "A440" ]
        LASTEST_FIRMWARE="A440";     DRIVE_CAPACITY="600 GB"; PROFILE="hdd_sas"; FIRMWARE_16_OR_NOT=1 ;;
      "HUC109090CSS600") ### fwversions = [ "A222", "A2D0", "A350", "A440" ]
        LASTEST_FIRMWARE="A440";     DRIVE_CAPACITY="900 GB"; PROFILE="hdd_sas"; FIRMWARE_16_OR_NOT=1 ;;
      "WD1002FBYS-02A6B0") # fwversions = [ "03.02C06" ]
       LASTEST_FIRMWARE="03.02C06";  DRIVE_CAPACITY="1 TB"; PROFILE="hdd_sata"; FIRMWARE_16_OR_NOT=1 ;;
      "MACH8_IOPS")      # fwversions = [ "2755" ]
        LASTEST_FIRMWARE="2828";     DRIVE_CAPACITY="100 GB"; PROFILE="ssd_sata"; FIRMWARE_16_OR_NOT=1 ;;
      "HUSSL4010BSS600")  
        LASTEST_FIRMWARE="A190";     DRIVE_CAPACITY="100 GB"; PROFILE="ssd_sas" ; FIRMWARE_16_OR_NOT=1 ;;
      "HUSSL4020BSS600")  
        LASTEST_FIRMWARE="A190";     DRIVE_CAPACITY="200 GB"; PROFILE="ssd_sas" ; FIRMWARE_16_OR_NOT=1 ;;
      "HUSSL4040BSS600")  
        LASTEST_FIRMWARE="A190";     DRIVE_CAPACITY="400 GB"; PROFILE="ssd_sas" ; FIRMWARE_16_OR_NOT=1 ;;
      "HUC106030CSS600")  
        LASTEST_FIRMWARE="A430";     DRIVE_CAPACITY="300 GB"; PROFILE="hdd_sas" ; FIRMWARE_16_OR_NOT=1 ;;
      "HUC106060CSS600")  
        LASTEST_FIRMWARE="A430";     DRIVE_CAPACITY="600 GB"; PROFILE="hdd_sas" ; FIRMWARE_16_OR_NOT=1 ;;
      "HUS156045VLS600")  
        LASTEST_FIRMWARE="A760";     DRIVE_CAPACITY="450 GB"; PROFILE="hdd_sas" ; FIRMWARE_16_OR_NOT=1 ;;
      "HDS725050KLA360")  
        LASTEST_FIRMWARE="K2AOAD1A"; DRIVE_CAPACITY="500 GB"; PROFILE="hdd_sata" ; FIRMWARE_16_OR_NOT=1 ;;
      "HUS724040ALA640")  
        LASTEST_FIRMWARE="MFAOAAC0"; DRIVE_CAPACITY="4 TB";   PROFILE="hdd_sata" ; FIRMWARE_16_OR_NOT=1 ;;
      "HUS724030ALA640")  
        LASTEST_FIRMWARE="MF8OAAC0"; DRIVE_CAPACITY="3 TB";   PROFILE="hdd_sata" ; FIRMWARE_16_OR_NOT=1 ;;
      "HUS724020ALA640")  
        LASTEST_FIRMWARE="MF6OAAC0"; DRIVE_CAPACITY="2 TB";   PROFILE="hdd_sata" ; FIRMWARE_16_OR_NOT=1 ;;
      "M8ISB2B-200UC")  
        LASTEST_FIRMWARE="2832";     DRIVE_CAPACITY="200 GB"; PROFILE="ssd_sata" ; FIRMWARE_16_OR_NOT=1 ;;
      "ST4000NM0033-9ZM170")  
        LASTEST_FIRMWARE="SN03";     DRIVE_CAPACITY="4 TB";   PROFILE="hdd_sata" ; FIRMWARE_16_OR_NOT=1 ;;

    #case ${DRIVE_MODEL} in 
    #  "HUA722050CLA330") # fwversions = [ "JP2OA3GB", "JP2OA3MA", "JP2OA3PA" ]
    #    LASTEST_FIRMWARE="JP2OA3PA"; DRIVE_CAPACITY="500 GB"; PROFILE="hdd_sata"; FIRMWARE_15_OR_NOT=1 ;;
    #  "HUA722010CLA330") # fwversions = [ "JP4OA3GB", "JP4OA3MA", "JP4OA3PA" ]
    #    LASTEST_FIRMWARE="JP4OA3PA"; DRIVE_CAPACITY="1 TB"; PROFILE="hdd_sata"; FIRMWARE_15_OR_NOT=1 ;;
    #  "HUA722020ALA330") # fwversions = [ "JKAOA20N", "JKAOA28A", "JKAOA3GA", "JKAOA3MA", "JKAOA3PA" ]
    #    LASTEST_FIRMWARE="JKAOA3PA"; DRIVE_CAPACITY="2 TB"; PROFILE="hdd_sata"; FIRMWARE_15_OR_NOT=1 ;;
    #  "HUA723020ALA640") # fwversions = [ "MK7OA6L0", "MK7OA8P0", "MK7OAA50" ]
    #    LASTEST_FIRMWARE="MK7OAA50"; DRIVE_CAPACITY="2 TB"; PROFILE="hdd_sata"; FIRMWARE_15_OR_NOT=1 ;;
    #  "HUA723030ALA640") # fwversions = [ "MKAOA5V0", "MKAOA6L0", "MKAOA8P0",  "MKAOAA50" ]
    #    LASTEST_FIRMWARE="MKAOAA50"; DRIVE_CAPACITY="3 TB"; PROFILE="hdd_sata"; FIRMWARE_15_OR_NOT=1 ;;
    #  "HUSSL4010ASS600") # fwversions = [ "A131", "A182" ]
    #    LASTEST_FIRMWARE="A182";     DRIVE_CAPACITY="100 GB"; PROFILE="ssd_sas"; FIRMWARE_15_OR_NOT=1 ;;
    #  "HUSSL4020ASS600") # fwversions = [ "A131", "A182" ]
    #    LASTEST_FIRMWARE="A182";     DRIVE_CAPACITY="200 GB"; PROFILE="ssd_sas"; FIRMWARE_15_OR_NOT=1 ;;
    #  "HUSSL4040ASS600") # fwversions = [ "A131", "A182" ]
    #    LASTEST_FIRMWARE="A182";     DRIVE_CAPACITY="400 GB"; PROFILE="ssd_sas"; FIRMWARE_15_OR_NOT=1 ;;
    #  "HUC109030CSS600") ### fwversions = [ "A222", "A2D0", "A350", "A440" ]
    #    LASTEST_FIRMWARE="A2D0";     DRIVE_CAPACITY="300 GB"; PROFILE="hdd_sas"; FIRMWARE_15_OR_NOT=1 ;;
    #  "HUC109060CSS600") ### fwversions = [ "A222", "A2D0", "A350", "A440" ]
    #    LASTEST_FIRMWARE="A2D0";     DRIVE_CAPACITY="600 GB"; PROFILE="hdd_sas"; FIRMWARE_15_OR_NOT=1 ;;
    #  "HUC109090CSS600") ### fwversions = [ "A222", "A2D0", "A350", "A440" ]
    #    LASTEST_FIRMWARE="A2D0";     DRIVE_CAPACITY="900 GB"; PROFILE="hdd_sas"; FIRMWARE_15_OR_NOT=1 ;;
    #  "WD1002FBYS-02A6B0") # fwversions = [ "03.02C06" ]
    #   LASTEST_FIRMWARE="03.02C06";  DRIVE_CAPACITY="1 TB"; PROFILE="hdd_sata"; FIRMWARE_15_OR_NOT=1 ;;
    #  "MACH8_IOPS")      # fwversions = [ "2755" ]
    #    LASTEST_FIRMWARE="2755";     DRIVE_CAPACITY="100 GB"; PROFILE="ssd_sata"; FIRMWARE_15_OR_NOT=1 ;;

#######################################################################################
####  START
###   #- Not from Drive Firmware Package Version 1.5
###   Not from Drive Firmware Package Version 1.6
##    But from "OneFS.7.1.0.0/src/isilon/lib/isi_hw/drive_config.gc" file
##
#     # cat src/isilon/lib/isi_hw/drive_config.gc|egrep "model = |fwversions =|capacity = |profile = "
#     # cat src/isilon/lib/isi_hw/drive_config.gc|egrep "model = |fwversions =|capacity = |profile = "|sed 's:_gigabyte: GB:'|sed 's:_terabyte: TB:'|sed 's:fwversions = \[ :LASTEST_FIRMWARE=:'|sed 's: ];:;:'|sed 's:model = ::'|sed 's:capacity = :DRIVE_CAPACITY=":'|sed 's:GB;:GB"; :'|sed 's:profile = :PROFILE=":'|sed 's:boot;:boot";:'|sed 's:hdd_sas;:hdd_sas";:'|sed 's:hdd_sata;:hdd_sata";:'|sed 's:ssd_sas;:ssd_sas";:'|sed 's:ssd_sata;:ssd_sata";:'

  ## Modified on Nov-3-2013 : START ##

  #FW15#"MACH8_IOPS")  LASTEST_FIRMWARE="2755", "2828";  DRIVE_CAPACITY="100 GB";  PROFILE="ssd_sata" ;;
  #"M8ISB2B-200UC")  LASTEST_FIRMWARE="2686", "2832";  DRIVE_CAPACITY="200 GB";  PROFILE="ssd_sata" ;;
  #FW16#"M8ISB2B-200UC")  LASTEST_FIRMWARE="2832";  DRIVE_CAPACITY="200 GB";  PROFILE="ssd_sata" ;;
  "MACH16 M16ISD2-100UCT")  LASTEST_FIRMWARE="00000061";  DRIVE_CAPACITY="100 GB";  PROFILE="ssd_sata" ;;
  "P300-MTFDDAC100SAL")  LASTEST_FIRMWARE="0001";  DRIVE_CAPACITY="100 GB";  PROFILE="ssd_sata" ;;
  "P300-MTFDDAC200SAL")  LASTEST_FIRMWARE="0001";  DRIVE_CAPACITY="200 GB";  PROFILE="ssd_sata" ;;
  #FW15#"HUSSL4010ASS600")  LASTEST_FIRMWARE="A131", "A182";  DRIVE_CAPACITY="100 GB";  PROFILE="ssd_sas" ;;
  #FW15#"HUSSL4020ASS600")  LASTEST_FIRMWARE="A131", "A182";  DRIVE_CAPACITY="200 GB";  PROFILE="ssd_sas" ;;
  #FW15#"HUSSL4040ASS600")  LASTEST_FIRMWARE="A131", "A182";  DRIVE_CAPACITY="400 GB";  PROFILE="ssd_sas" ;;
  #"HUSSL4010BSS600")  LASTEST_FIRMWARE="A110", "A190";  DRIVE_CAPACITY="100 GB";  PROFILE="ssd_sas" ;;
  #FW16#"HUSSL4010BSS600")  LASTEST_FIRMWARE="A190";  DRIVE_CAPACITY="100 GB";  PROFILE="ssd_sas" ;;
  #"HUSSL4020BSS600")  LASTEST_FIRMWARE="A110", "A190";  DRIVE_CAPACITY="200 GB";  PROFILE="ssd_sas" ;;
  #FW16#"HUSSL4020BSS600")  LASTEST_FIRMWARE="A190";  DRIVE_CAPACITY="200 GB";  PROFILE="ssd_sas" ;;
  #"HUSSL4040BSS600")  LASTEST_FIRMWARE="A110", "A190";  DRIVE_CAPACITY="400 GB";  PROFILE="ssd_sas" ;;
  #FW16#"HUSSL4040BSS600")  LASTEST_FIRMWARE="A190";  DRIVE_CAPACITY="400 GB";  PROFILE="ssd_sas" ;;
  "HUSML4020ASS600")  LASTEST_FIRMWARE="A337";  DRIVE_CAPACITY="200 GB";  PROFILE="ssd_sas" ;;
  "HUSML4040ASS600")  LASTEST_FIRMWARE="A337";  DRIVE_CAPACITY="400 GB";  PROFILE="ssd_sas" ;;
  "HUSMM8020ASS200")  LASTEST_FIRMWARE="A100";  DRIVE_CAPACITY="200 GB";  PROFILE="ssd_sas" ;;
  "HUSMM8040ASS200")  LASTEST_FIRMWARE="A100";  DRIVE_CAPACITY="400 GB";  PROFILE="ssd_sas" ;;
  "HUSMM8080ASS200")  LASTEST_FIRMWARE="A100";  DRIVE_CAPACITY="800 GB";  PROFILE="ssd_sas" ;;
  #"HDT725025VLA380")  LASTEST_FIRMWARE="V5DOA52A", "V5DOA73A";  DRIVE_CAPACITY="160 GB";  PROFILE="hdd_sata" ;;
  "HDT725025VLA380")  LASTEST_FIRMWARE="V5DOA73A";  DRIVE_CAPACITY="160 GB";  PROFILE="hdd_sata" ;;
  #"HDP725025GLA380")  LASTEST_FIRMWARE="GM2OA52A", "GM2OA5CA";  DRIVE_CAPACITY="160 GB";  PROFILE="hdd_sata" ;;
  "HDP725025GLA380")  LASTEST_FIRMWARE="GM2OA5CA";  DRIVE_CAPACITY="160 GB";  PROFILE="hdd_sata" ;;
  #"HDT725025VLA380")  LASTEST_FIRMWARE="V5DOA52A", "V5DOA73A";  DRIVE_CAPACITY="250 GB";  PROFILE="hdd_sata" ;;
  "HDT725025VLA380")  LASTEST_FIRMWARE="V5DOA73A";  DRIVE_CAPACITY="250 GB";  PROFILE="hdd_sata" ;;
  #"HDP725025GLA380")  LASTEST_FIRMWARE="GM2OA52A", "GM2OA5CA";  DRIVE_CAPACITY="250 GB";  PROFILE="hdd_sata" ;;
  "HDP725025GLA380")  LASTEST_FIRMWARE="GM2OA5CA";  DRIVE_CAPACITY="250 GB";  PROFILE="hdd_sata" ;;
  #"HDS725050KLA360")  LASTEST_FIRMWARE="K2AOA10C", "K2AOA51A", "K2AOAB0A", "K2AOAD1A";  DRIVE_CAPACITY="400 GB";  PROFILE="hdd_sata" ;;
  #FW16#"HDS725050KLA360")  LASTEST_FIRMWARE="K2AOAD1A";  DRIVE_CAPACITY="400 GB";  PROFILE="hdd_sata" ;;
  "HUA721050KLA330")  LASTEST_FIRMWARE="GK6OAB0A";  DRIVE_CAPACITY="400 GB";  PROFILE="hdd_sata" ;;
  #"HDS724040KLSA80")  LASTEST_FIRMWARE="KFAOA46A", "KFAOAC6A";  DRIVE_CAPACITY="400 GB";  PROFILE="hdd_sata" ;;
  "HDS724040KLSA80")  LASTEST_FIRMWARE="KFAOAC6A";  DRIVE_CAPACITY="400 GB";  PROFILE="hdd_sata" ;;
  "HUS154545VLS300")  LASTEST_FIRMWARE="A570";  DRIVE_CAPACITY="450 GB";  PROFILE="hdd_sas" ;;
  #"HUS156045VLS600")  LASTEST_FIRMWARE="A5D0", "A760";  DRIVE_CAPACITY="450 GB";  PROFILE="hdd_sas" ;;
  #FW16#"HUS156045VLS600")  LASTEST_FIRMWARE="A760";  DRIVE_CAPACITY="450 GB";  PROFILE="hdd_sas" ;;
  #"HDS725050KLA360")  LASTEST_FIRMWARE="K2AOA10C", "K2AOA51A", "K2AOAB0A", "K2AOAD1A";  DRIVE_CAPACITY="500 GB";  PROFILE="hdd_sata" ;;
  #FW16#"HDS725050KLA360")  LASTEST_FIRMWARE="K2AOAD1A";  DRIVE_CAPACITY="500 GB";  PROFILE="hdd_sata" ;;
  "HUA721050KLA330")  LASTEST_FIRMWARE="GK6OAB0A";  DRIVE_CAPACITY="500 GB";  PROFILE="hdd_sata" ;;
  #"HUA721075KLA330")  LASTEST_FIRMWARE="GK8OAB0A", "GK8OA70M";  DRIVE_CAPACITY="750 GB";  PROFILE="hdd_sata" ;;
  "HUA721075KLA330")  LASTEST_FIRMWARE="GK8OAB0A";  DRIVE_CAPACITY="750 GB";  PROFILE="hdd_sata" ;;
  #"HUA721010KLA330")  LASTEST_FIRMWARE="GKAOA70M", "GKAOAB0A";  DRIVE_CAPACITY="1 TB";  PROFILE="hdd_sata" ;;
  "HUA721010KLA330")  LASTEST_FIRMWARE="GKAOAB0A";  DRIVE_CAPACITY="1 TB";  PROFILE="hdd_sata" ;;
  #FW15#"HUA722020ALA330")  LASTEST_FIRMWARE="JKAOA20N", "JKAOA28A", "JKAOA3GA", "JKAOA3MA", "JKAOA3PA";  DRIVE_CAPACITY="2 TB";  PROFILE="hdd_sata" ;;
  #FW15#"HUA722050CLA330")  LASTEST_FIRMWARE="JP2OA3GB", "JP2OA3MA", "JP2OA3PA";  DRIVE_CAPACITY="500 GB";  PROFILE="hdd_sata" ;;
  #FW15#"HUA722010CLA330")  LASTEST_FIRMWARE="JP4OA3GB", "JP4OA3MA", "JP4OA3PA";  DRIVE_CAPACITY="1 TB";  PROFILE="hdd_sata" ;;
  #"HUC106030CSS600")  LASTEST_FIRMWARE="A202", "A430";  DRIVE_CAPACITY="300 GB";  PROFILE="hdd_sas" ;;
  #FW16#"HUC106030CSS600")  LASTEST_FIRMWARE="A430";  DRIVE_CAPACITY="300 GB";  PROFILE="hdd_sas" ;;
  #"HUC106060CSS600")  LASTEST_FIRMWARE="A202", "A430";  DRIVE_CAPACITY="600 GB";  PROFILE="hdd_sas" ;;
  #FW16#"HUC106060CSS600")  LASTEST_FIRMWARE="A430";  DRIVE_CAPACITY="600 GB";  PROFILE="hdd_sas" ;;
  #FW15#"HUA723020ALA640")  LASTEST_FIRMWARE="MK7OA6L0", "MK7OA8P0", "MK7OAA50";  DRIVE_CAPACITY="2 TB";  PROFILE="hdd_sata" ;;
  #FW15#"HUA723030ALA640")  LASTEST_FIRMWARE="MKAOA5V0", "MKAOA6L0", "MKAOA8P0",  "MKAOAA50";  DRIVE_CAPACITY="3 TB";  PROFILE="hdd_sata" ;;
  #"HUA722050CLA330")  LASTEST_FIRMWARE="JP2OA3GB", "JP2OA3MA", "JP2OA3PA";  DRIVE_CAPACITY="160 GB";  PROFILE="hdd_sata" ;;
  "HUA722050CLA330")  LASTEST_FIRMWARE="JP2OA3PA";  DRIVE_CAPACITY="160 GB";  PROFILE="hdd_sata" ;;
  #FW15#"HUC109030CSS600")  LASTEST_FIRMWARE="A222", "A2D0", "A350", "A440";  DRIVE_CAPACITY="300 GB";  PROFILE="hdd_sas" ;;
  #FW15#"HUC109060CSS600")  LASTEST_FIRMWARE="A222", "A2D0", "A350", "A440";  DRIVE_CAPACITY="600 GB";  PROFILE="hdd_sas" ;;
  #FW15#"HUC109090CSS600")  LASTEST_FIRMWARE="A222", "A2D0", "A350", "A440";  DRIVE_CAPACITY="900 GB";  PROFILE="hdd_sas" ;;
  "HUS724040ALE640")  LASTEST_FIRMWARE="MJAOA3K0";  DRIVE_CAPACITY="4 TB";  PROFILE="hdd_sata";;
  #"HUS724040ALA640")  LASTEST_FIRMWARE="MFAOA8B0", "MFAOAAC0";  DRIVE_CAPACITY="4 TB";  PROFILE="hdd_sata" ;;
  #FW16#"HUS724040ALA640")  LASTEST_FIRMWARE="MFAOAAC0";  DRIVE_CAPACITY="4 TB";  PROFILE="hdd_sata" ;;
  #"HUS724030ALA640")  LASTEST_FIRMWARE="MF8OA8B0", "MF8OAAC0";  DRIVE_CAPACITY="3 TB";  PROFILE="hdd_sata" ;;
  #FW16#"HUS724030ALA640")  LASTEST_FIRMWARE="MF8OAAC0";  DRIVE_CAPACITY="3 TB";  PROFILE="hdd_sata" ;;
  #"HUS724020ALA640")  LASTEST_FIRMWARE="MF6OA8B0", "MF6OAAC0";  DRIVE_CAPACITY="2 TB";  PROFILE="hdd_sata" ;;
  #FW16#"HUS724020ALA640")  LASTEST_FIRMWARE="MF6OAAC0";  DRIVE_CAPACITY="2 TB";  PROFILE="hdd_sata" ;;
  "HUC10603 CLAR300")  LASTEST_FIRMWARE="C330";  DRIVE_CAPACITY="300 GB";  PROFILE="boot" ;;
  "HUC101212CSS600")  LASTEST_FIRMWARE="A469";  DRIVE_CAPACITY="1200 GB";  PROFILE="hdd_sas" ;;
  "6Y160M0")  LASTEST_FIRMWARE="YAR511W0";  DRIVE_CAPACITY="160 GB";  PROFILE="hdd_sata" ;;
  #"6L160M0")  LASTEST_FIRMWARE="BANC1G10", "BACE1G10", "BACE1G20";  DRIVE_CAPACITY="160 GB";  PROFILE="hdd_sata" ;;
  "6L160M0")  LASTEST_FIRMWARE="BACE1G20";  DRIVE_CAPACITY="160 GB";  PROFILE="hdd_sata" ;;
  "7Y250M0")  LASTEST_FIRMWARE="YAR511W0";  DRIVE_CAPACITY="250 GB";  PROFILE="hdd_sata" ;;
  "7L250S0")  LASTEST_FIRMWARE="BANC1G10";  DRIVE_CAPACITY="250 GB";  PROFILE="hdd_sata" ;;
  "WD2502ABYS-02B7A0")  LASTEST_FIRMWARE="02.05B03";  DRIVE_CAPACITY="250 GB";  PROFILE="hdd_sata" ;;
  "WD5002ABYS-02B1B0")  LASTEST_FIRMWARE="02.05B03";  DRIVE_CAPACITY="500 GB";  PROFILE="hdd_sata" ;;
  #FW15#"WD1002FBYS-02A6B0")  LASTEST_FIRMWARE="03.02C06";  DRIVE_CAPACITY="1 TB";  PROFILE="hdd_sata" ;;
  "WD2002FYPS-01U1B0")  LASTEST_FIRMWARE="04.05G04";  DRIVE_CAPACITY="2 TB";  PROFILE="hdd_sata" ;;
  "ST3450857SS")  LASTEST_FIRMWARE="IS03";  DRIVE_CAPACITY="450 GB";  PROFILE="hdd_sas" ;;
  "ST31000524NS")  LASTEST_FIRMWARE="IS00";  DRIVE_CAPACITY="1 TB";  PROFILE="hdd_sata" ;;
  "ST32000644NS")  LASTEST_FIRMWARE="IS00";  DRIVE_CAPACITY="2 TB";  PROFILE="hdd_sata" ;;
  "ST9300603SS")  LASTEST_FIRMWARE="IS01";  DRIVE_CAPACITY="300 GB";  PROFILE="hdd_sas" ;;
  "ST9600204SS")  LASTEST_FIRMWARE="IS01";  DRIVE_CAPACITY="600 GB";  PROFILE="hdd_sas" ;;
  "ST3750641NS")  LASTEST_FIRMWARE="4IST";  DRIVE_CAPACITY="750 GB";  PROFILE="hdd_sata" ;;
  #"ST33000650NS")  LASTEST_FIRMWARE="0002", "0006";  DRIVE_CAPACITY="3 TB";  PROFILE="hdd_sata" ;;
  "ST33000650NS")  LASTEST_FIRMWARE="0006";  DRIVE_CAPACITY="3 TB";  PROFILE="hdd_sata" ;;
  "ST9300605SS")  LASTEST_FIRMWARE="IS00";  DRIVE_CAPACITY="300 GB";  PROFILE="hdd_sas" ;;
  "ST9600205SS")  LASTEST_FIRMWARE="IS00";  DRIVE_CAPACITY="600 GB";  PROFILE="hdd_sas" ;;
  "ST9900805SS")  LASTEST_FIRMWARE="IS00";  DRIVE_CAPACITY="900 GB";  PROFILE="hdd_sas" ;;
  "ST500NM0011")  LASTEST_FIRMWARE="SN03";  DRIVE_CAPACITY="500 GB";  PROFILE="hdd_sata" ;;
  "ST1000NM0011")  LASTEST_FIRMWARE="SN03";  DRIVE_CAPACITY="1 TB";  PROFILE="hdd_sata" ;;
  "ST2000NM0011")  LASTEST_FIRMWARE="SN03";  DRIVE_CAPACITY="2 TB";  PROFILE="hdd_sata" ;;
  #"ST4000NM0033-9ZM170")  LASTEST_FIRMWARE="SN02", "SN03";  DRIVE_CAPACITY="4 TB";  PROFILE="hdd_sata" ;;
  #FW16#"ST4000NM0033-9ZM170")  LASTEST_FIRMWARE="SN03";  DRIVE_CAPACITY="4 TB";  PROFILE="hdd_sata" ;;
  #"ST930060 CLAR300")  LASTEST_FIRMWARE="CS18", "CS19";  DRIVE_CAPACITY="300 GB";  PROFILE="boot" ;;
  "ST930060_CLAR300")  LASTEST_FIRMWARE="CS19";  DRIVE_CAPACITY="300 GB";  PROFILE="boot" ;;
  "ST330006CLAR3000")  LASTEST_FIRMWARE="YE04";  DRIVE_CAPACITY="3 TB";  PROFILE="hdd_sas" ;;
  #"ST33000652SS")  LASTEST_FIRMWARE="0005", "0006";  DRIVE_CAPACITY="3 TB";  PROFILE="hdd_sas" ;;
  "ST33000652SS")  LASTEST_FIRMWARE="0006";  DRIVE_CAPACITY="3 TB";  PROFILE="hdd_sas" ;;
  "ST1000NM0033-9ZM173")  LASTEST_FIRMWARE="SN03";  DRIVE_CAPACITY="1 TB";  PROFILE="hdd_sata" ;;
  #"SanDisk SSD P4 8GB")  LASTEST_FIRMWARE="SSD 8.00", "SSD 8.10";  DRIVE_CAPACITY="8 GB";  PROFILE="boot" ;;
  "SanDisk SSD P4 8GB")  LASTEST_FIRMWARE="SSD 8.10";  DRIVE_CAPACITY="8 GB";  PROFILE="boot" ;;
  #"NETLIST SSD 8GB-001")  LASTEST_FIRMWARE="S5FAM017", "S5FAM018";  DRIVE_CAPACITY="8 GB";  PROFILE="boot" ;;
  #"NETLIST SSD 8GB-001")  LASTEST_FIRMWARE="S5FAM018";  DRIVE_CAPACITY="8 GB";  PROFILE="boot" ;;
  "SSD_8GB-001")  LASTEST_FIRMWARE="S5FAM018";  DRIVE_CAPACITY="8 GB";  PROFILE="boot" ;;
  "SSD-S0008S-7112")  LASTEST_FIRMWARE="2.11ME";  DRIVE_CAPACITY="8 GB";  PROFILE="boot" ;;
  "SMART iSATA SGSLM3E8GBM01ISI")  LASTEST_FIRMWARE="Ver7.02k";  DRIVE_CAPACITY="8 GB";  PROFILE="boot" ;;

  ## Modified on Nov-3-2013 : END ##

#      "HUS154545VLS300")
#        LASTEST_FIRMWARE="A570"; DRIVE_CAPACITY="450 GB" ;;
#      "HUS156045VLS600")
#        LASTEST_FIRMWARE="A5D0"; DRIVE_CAPACITY="450 GB" ;;
#      "WD2502ABYS-02B7A0")
#        LASTEST_FIRMWARE="02.05B03"; DRIVE_CAPACITY="250 GB" ;;
#      "HUC106060CSS600")
#        LASTEST_FIRMWARE="A202"; DRIVE_CAPACITY="600 GB" ;;
#      "HDS725050KLA360")
#        LASTEST_FIRMWARE="K2AOAD1A"; DRIVE_CAPACITY="500 GB" ;;
#      "HUA721010KLA330")
#        LASTEST_FIRMWARE="GKAOAB0A"; DRIVE_CAPACITY="1 TB" ;;
#      "HUA721050KLA330")
#        LASTEST_FIRMWARE="GK6OAB0A"; DRIVE_CAPACITY="500 GB" ;;
#      "HUA721075KLA330") # fwversions = [ "GK8OAB0A", "GK8OA70M" ];
#        LASTEST_FIRMWARE="GK8OAB0A"; DRIVE_CAPACITY="750 GB" ;;
#      "MTFDDAC200SAL")
#        LASTEST_FIRMWARE="0001"; DRIVE_CAPACITY="200 GB" ;;
#      "M8ISB2B-200UC")
#        LASTEST_FIRMWARE="2686"; DRIVE_CAPACITY="200 GB" ;;
#      "MACH16 M16ISD2-100UCT")
#        LASTEST_FIRMWARE="00000061"; DRIVE_CAPACITY="100 GB" ;;
#      "MTFDDAC100SAL")
#        LASTEST_FIRMWARE="0001"; DRIVE_CAPACITY="100 GB" ;;
#      "HUSSL4010BSS600")
#        LASTEST_FIRMWARE="A110"; DRIVE_CAPACITY="100 GB" ;;
#      "HUSSL4020BSS600")
#        LASTEST_FIRMWARE="A110"; DRIVE_CAPACITY="200 GB" ;;
#      "HUSSL4040BSS600")
#        LASTEST_FIRMWARE="A110"; DRIVE_CAPACITY="400 GB" ;;
#      "HUSML4020ASS600")
#        LASTEST_FIRMWARE="A337"; DRIVE_CAPACITY="200 GB" ;;
#      "HUSML4040ASS600")
#        LASTEST_FIRMWARE="A337"; DRIVE_CAPACITY="400 GB" ;;
#      "HDT725025VLA380")
#        LASTEST_FIRMWARE="V5DOA73A"; DRIVE_CAPACITY="160 GB" ;;
#      "HDP725025GLA380")
#        LASTEST_FIRMWARE="GM2OA5CA"; DRIVE_CAPACITY="160 GB" ;;
#      "HDT725025VLA380")
#        LASTEST_FIRMWARE="V5DOA73A"; DRIVE_CAPACITY="250 GB" ;;
#      "HDP725025GLA380")
#        LASTEST_FIRMWARE="GM2OA5CA"; DRIVE_CAPACITY="250 GB" ;;
#      "HDS724040KLSA80")
#        LASTEST_FIRMWARE="KFAOAC6A"; DRIVE_CAPACITY="400 GB" ;;
#      "HUA721050KLA330")
#        LASTEST_FIRMWARE="GK6OAB0A"; DRIVE_CAPACITY="500 GB" ;;
#      "HUC106030CSS600")
#        LASTEST_FIRMWARE="A202"; DRIVE_CAPACITY="300 GB" ;;
#      "HUA722050CLA330")
#        LASTEST_FIRMWARE="JP2OA3PA"; DRIVE_CAPACITY="160 GB" ;;
#      "HUS724040ALE640")
#        LASTEST_FIRMWARE="MJAOA3K0"; DRIVE_CAPACITY="4 TB" ;;
#      "HUS724040ALA640")
#        LASTEST_FIRMWARE="MFAOAAC0"; DRIVE_CAPACITY="4 TB" ;;
#      "HUS724030ALA640")
#        LASTEST_FIRMWARE="MF8OAAC0"; DRIVE_CAPACITY="3 TB" ;;
#      "HUS724020ALA640")
#        LASTEST_FIRMWARE="MF6OAAC0"; DRIVE_CAPACITY="2 TB" ;;
#      "HUC10603 CLAR300")
#        LASTEST_FIRMWARE="C330"; DRIVE_CAPACITY="300 GB" ;;
#      "6Y160M0")
#        LASTEST_FIRMWARE="YAR511W0"; DRIVE_CAPACITY="160 GB" ;;
#      "6L160M0")
#        LASTEST_FIRMWARE="BACE1G20"; DRIVE_CAPACITY="160 GB" ;;
#      "7Y250M0")
#        LASTEST_FIRMWARE="YAR511W0"; DRIVE_CAPACITY="250 GB" ;;
#      "7L250S0")
#        LASTEST_FIRMWARE="BANC1G10"; DRIVE_CAPACITY="250 GB" ;;
#      "WD5002ABYS-02B1B0")
#        LASTEST_FIRMWARE="02.05B03"; DRIVE_CAPACITY="500 GB" ;;
#      "WD2002FYPS-01U1B0")
#        LASTEST_FIRMWARE="04.05G04"; DRIVE_CAPACITY="2 TB" ;;
#      "ST3450857SS")
#        LASTEST_FIRMWARE="IS03"; DRIVE_CAPACITY="450 GB" ;;
#      "ST31000524NS")
#        LASTEST_FIRMWARE="IS00"; DRIVE_CAPACITY="1 TB" ;;
#      "ST32000644NS")
#        LASTEST_FIRMWARE="IS00"; DRIVE_CAPACITY="2 TB" ;;
#      "ST9300603SS")
#        LASTEST_FIRMWARE="IS01"; DRIVE_CAPACITY="300 GB" ;;
#      "ST9600204SS")
#        LASTEST_FIRMWARE="IS01"; DRIVE_CAPACITY="600 GB" ;;
#      "ST3750641NS")
#        LASTEST_FIRMWARE="4IST"; DRIVE_CAPACITY="750 GB" ;;
#      "ST33000650NS")
#        LASTEST_FIRMWARE="0006"; DRIVE_CAPACITY="3 TB" ;;
#      "ST9300605SS")
#        LASTEST_FIRMWARE="IS00"; DRIVE_CAPACITY="300 GB" ;;
#      "ST9600205SS")
#        LASTEST_FIRMWARE="IS00"; DRIVE_CAPACITY="600 GB" ;;
#      "ST9900805SS")
#        LASTEST_FIRMWARE="IS00"; DRIVE_CAPACITY="900 GB" ;;
#      "ST500NM0011")
#        LASTEST_FIRMWARE="SN03"; DRIVE_CAPACITY="500 GB" ;;
#      "ST1000NM0011")
#        LASTEST_FIRMWARE="SN03"; DRIVE_CAPACITY="1 TB" ;;
#      "ST2000NM0011")
#        LASTEST_FIRMWARE="SN03"; DRIVE_CAPACITY="2 TB" ;;
#      "ST4000NM0033-9ZM170")
#        LASTEST_FIRMWARE="SN03"; DRIVE_CAPACITY="4 TB" ;;
#      "ST930060 CLAR300") 
#        LASTEST_FIRMWARE="CS18"; DRIVE_CAPACITY="300 GB" ;;
#      "SanDisk SSD P4 8GB")
#        LASTEST_FIRMWARE="SSD 8.10"; DRIVE_CAPACITY="8 GB" ;;
#      "NETLIST SSD 8GB-001")
#        LASTEST_FIRMWARE="S5FAM018"; DRIVE_CAPACITY="8 GB" ;;
#      "SMART iSATA SGSLM3E8GBM01ISI")
#        LASTEST_FIRMWARE="Ver7.02k"; DRIVE_CAPACITY="8 GB" ;;
#      "SSD-S0008S-7112")
#        LASTEST_FIRMWARE="2.11ME"; DRIVE_CAPACITY="8 GB" ;;

#    END
##   Not from Drive Firmware Package Version 1.5
##### But from "OneFS.7.1.0.0/src/isilon/lib/isi_hw/drive_config.gc" file
######################################################################################

      *) 
        FIRMWARE_NA=1
        PROFILE=""
        LASTEST_FIRMWARE=""
        DRIVE_CAPACITY=""
        ;;
    esac
  
    printf "  | %11s | %15s | %20s | %8s | %8s |" ${DRIVE_COUNT} ${DRIVE_VENDOR} ${DRIVE_MODEL} "${DRIVE_CAPACITY}" ${PROFILE}
    if [[ $FIRMWARE_NA -eq 1 ]]; then
      printf " %16s | %16s | %24s |\n" ${DRIVE_FIRMWARE} "N/A" ""
    elif [[ ${DRIVE_FIRMWARE} == ${LASTEST_FIRMWARE} ]]; then
      printf " %16s | %16s |" ${DRIVE_FIRMWARE} ${LASTEST_FIRMWARE}
    else
      if [[ ${DRIVE_FIRMWARE} > ${LASTEST_FIRMWARE} ]]; then
        printf " [42;31m%16s[1;0m | [1;32m%16s[1;0m |" ${DRIVE_FIRMWARE} ${LASTEST_FIRMWARE}
      else
        printf " [1;31m%16s[1;0m | [1;32m%16s[1;0m |" ${DRIVE_FIRMWARE} ${LASTEST_FIRMWARE}
      fi
    fi

    if [[ $FIRMWARE_NA -ne 1 ]]; then
      #if [[ $FIRMWARE_15_OR_NOT -eq 1 ]]; then
      if [[ $FIRMWARE_16_OR_NOT -eq 1 ]]; then
        #printf " %24s |\n" "From Firmware PKG v1.5"
        printf " %24s |\n" "From Firmware PKG v1.6"
      else
        #printf " %22s |\n" "From drive_config.gc"
        #printf " [1;33m%24s[0m |\n" "Not included in PKG v1.5"
        printf " [1;33m%24s[0m |\n" "Not included in PKG v1.6"
        #NOT_INCLUDED_IN_FIRM_PKG_v15=1
        NOT_INCLUDED_IN_FIRM_PKG_v16=1
      fi
    fi

  done < ${TEMP_FILE}
  $ECHO "  +-------------+-----------------+----------------------+----------+----------+------------------+------------------+--------------------------+"

  #if [[ $NOT_INCLUDED_IN_FIRM_PKG_v15 -eq 1 ]]; then
  if [[ $NOT_INCLUDED_IN_FIRM_PKG_v16 -eq 1 ]]; then
    $ECHO "\n ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
    $ECHO " [1;33m: If you saw \"Not included in PKG v1.6\" in last column,                        :"
    #$ECHO " : which means Drive Firmware Package 1.5 does not have firmware for that Drive :"
    $ECHO " : which means Drive Firmware Package 1.6 does not have firmware for that Drive :"
    $ECHO " : So, even though it is not up-to-date firmware, no way to upgrade it,         :"
    #$ECHO " : at least, through Drive Firmware Package 1.5.                                :[0m"
    $ECHO " : at least, through Drive Firmware Package 1.6.                                :[0m"
    $ECHO " ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
  fi
  
  rm -f ${TEMP_FILE}
  #-------- Current drive and firmware comparison to latest firmware --------#

  #$ECHO "\n  As of Apr-1-2013, Latest Drive Firmware package release is"
  #$ECHO "  Isilon Drive Firmware Package 1.5 (Release date: 11/15/2012)"
  #$ECHO "  +-----------------+-----------------+----------+-------------------+"
  #$ECHO "  | Manufacturer    | Model           | Capacity | Firmware Revision |"
  #$ECHO "  +-----------------+-----------------+----------+-------------------+"
  #$ECHO "  | Hitachi         | HUA722050CLA330 | 500 GB   | JP2OA3PA          |"
  #$ECHO "  | Hitachi         | HUA722010CLA330 | 1 TB     | JP4OA3PA          |"
  #$ECHO "  | Hitachi         | HUA722020ALA330 | 2 TB     | JKAOA3PA          |"
  #$ECHO "  +-----------------+-----------------+----------+-------------------+"
  #$ECHO "  | Hitachi         | HUA723020ALA640 | 2 TB     | MK7OAA50          |"
  #$ECHO "  | Hitachi         | HUA723030ALA640 | 3 TB     | MKAOAA50          |"
  #$ECHO "  +-----------------+-----------------+----------+-------------------+"
  #$ECHO "  | Hitachi         | HUSSL4010ASS600 | 100 GB   | A182              |"
  #$ECHO "  | Hitachi         | HUSSL4020ASS600 | 200 GB   | A182              |"
  #$ECHO "  | Hitachi         | HUSSL4040ASS600 | 400 GB   | A182              |"
  #$ECHO "  +-----------------+-----------------+----------+-------------------+"
  #$ECHO "  | Hitachi         | HUC109030CSS600 | 300 GB   | A2D0              |"
  #$ECHO "  | Hitachi         | HUC109060CSS600 | 600 GB   | A2D0              |"
  #$ECHO "  | Hitachi         | HUC109090CSS600 | 900 GB   | A2D0              |"
  #$ECHO "  +-----------------+-----------------+----------+-------------------+"
  #$ECHO "  | Western Digital | WD1002FBYS      | 1 TB     | 03.02C06          |"
  #$ECHO "  +-----------------+-----------------+----------+-------------------+"
  #$ECHO "  | STEC            | MACH8 IOPS      | 100 GB   | 2755              |"
  #$ECHO "  +-----------------+-----------------+----------+-------------------+"

  $ECHO "\n  As of Nov-12-2013, Latest Drive Firmware package release is"
  $ECHO "  Isilon Drive Firmware Package 1.6 (Release date: Nov, 2013)"
  $ECHO "  +----------------------------+----------+---------------------+-------------------+"
  $ECHO "  |                            | Capacity |        Model        | Firmware revision |"
  $ECHO "  +----------------------------+----------+---------------------+-------------------+"
  $ECHO "  |                            |   500 GB | HUA722050CLA330     | JP2OA3PA          |"
  $ECHO "  | Hitachi Jupiter            |     1 TB | HUA722010CLA330     | JP4OA3PA          |"
  $ECHO "  |                            |     2 TB | HUA722020ALA330     | JKAOA3PA          |"
  $ECHO "  +----------------------------+----------+---------------------+-------------------+"
  $ECHO "  | Hitachi Mars               |     2 TB | HUA723020ALA640     | MK7OAA50          |"
  $ECHO "  |                            |     3 TB | HUA723030ALA640     | MKAOAA50          |"
  $ECHO "  +----------------------------+----------+---------------------+-------------------+"
  $ECHO "  |                            |     2 TB | HUS724020ALA640     | MF6OAAC0          |"
  $ECHO "  | Hitachi Mars-K Plus        |     3 TB | HUS724030ALA640     | MF8OAAC0          |"
  $ECHO "  |                            |     4 TB | HUS724040ALA640     | MFAOAAC0          |"
  $ECHO "  +----------------------------+----------+---------------------+-------------------+"
  $ECHO "  |                            |   100 GB | HUSSL4010ASS600     | A182              |"
  $ECHO "  |                            |   100 GB | HUSSL4010BSS600     | A190              |"
  $ECHO "  | Hitachi Ralston Peak       |   200 GB | HUSSL4020ASS600     | A182              |"
  $ECHO "  |                            |   200 GB | HUSSL4020BSS600     | A190              |"
  $ECHO "  |                            |   400 GB | HUSSL4040ASS600     | A182              |"
  $ECHO "  |                            |   400 GB | HUSSL4040BSS600     | A190              |"
  $ECHO "  +----------------------------+----------+---------------------+-------------------+"
  $ECHO "  | Hitachi Cobra-D            |   300 GB | HUC106030CSS600     | A430              |"
  $ECHO "  |                            |   600 GB | HUC106060CSS600     | A430              |"
  $ECHO "  +----------------------------+----------+---------------------+-------------------+"
  $ECHO "  |                            |   300 GB | HUC109030CSS600     | A440              |"
  $ECHO "  | Hitachi Cobra-E            |   600 GB | HUC109060CSS600     | A440              |"
  $ECHO "  |                            |   900 GB | HUC109090CSS600     | A440              |"
  $ECHO "  +----------------------------+----------+---------------------+-------------------+"
  $ECHO "  | Hitachi Viper-C            |   450 GB | HUS156045VLS600     | A760              |"
  $ECHO "  +----------------------------+----------+---------------------+-------------------+"
  $ECHO "  | Hitachi Deskstar           |   500 GB | HDS725050KLA360     | K2AOAD1A          |"
  $ECHO "  +----------------------------+----------+---------------------+-------------------+"
  $ECHO "  | STEC                       |   100 GB | MACH8 IOPS          | 2828              |"
  $ECHO "  |                            |   200 GB | M8ISB2B-200UC       | 2832              |"
  $ECHO "  +----------------------------+----------+---------------------+-------------------+"
  $ECHO "  | Western Digital RE3        |     1 TB | WD1002FBYS          | 03.02C06          |"
  $ECHO "  +----------------------------+----------+---------------------+-------------------+"
  $ECHO "  | Seagate Constellation ES.3 |     4 TB | ST4000NM0033-9ZM170 | SN03              |"
  $ECHO "  +----------------------------+----------+---------------------+-------------------+"
fi

CATEGORY="firmware"; BODY="Firmware version check with disk HUA723030ALA640"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ $IS_ONEFS_version5 -eq 1 ]]; then
    CMD="grep \"HUA723030ALA640\" ${CLU_ALL_ISI_RADISH}|sed 's:is HDS:is HITACHI HDS:'|sort -k5|awk '{print \$4,\$5,\$6}'|sort|uniq -c"; EXEC_CMD_ONLY
  else
    CMD="grep \"HUA723030ALA640\" ${CLU_ALL_ISI_RADISH}|sort -k5|awk '{print \$4,\$5,\$6}'|sort|uniq -c"; EXEC_CMD_ONLY
  fi
  if [[ `grep "HUA723030ALA640" ${CLU_ALL_ISI_RADISH}|egrep "FW:MK...[1-5].."|wc -l` -ne 0 ]]; then
    #$ECHO "\nPer KB-3594, with Hitachi 3 Terabyte drives, model HUA723030ALA640,"
    $ECHO "\nPer KB 89477, with Hitachi 3 Terabyte drives, model HUA723030ALA640,"
    $ECHO "read recovery error processing can result in requests that do not return within the timeout period."
    $ECHO "This error is resolved in firmware revision MK7OA6L0 or later," 
    $ECHO "which can be installed by upgrading to the latest OneFS firmware package."
  fi
fi

#CATEGORY="disk"; BODY="KB-2592 : (SAS expander physical link to 3TB disk devices can cause node panics and drive failure)"
CATEGORY="disk"; BODY="KB 89129 : (SAS expander physical link to 3TB disk devices can cause node panics and drive failure)"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  CMD="grep \"HUA723030ALA640\" ${CLU_ALL_ISI_RADISH}| grep \"MKAOA5V0\" |awk '{print \$1,\$4,\$5,\$6}'|sort|uniq -c|sed 's:/isi_radish\:Bay::'|sed 's:${IN_DIR}/::'"; EXEC_CMD_ONLY
  if [[ `grep "HUA723030ALA640" ${CLU_ALL_ISI_RADISH}|grep "MKAOA5V0"|wc -l` -ne 0 ]]; then
    $ECHO ""
    CMD="awk '{print FILENAME,\$0}' ${CLU_ALL}/isi_hw_status |grep Product| sed 's:/isi_hw_status: :g' |sed 's:${IN_DIR}/::g'"; EXEC_CMD_ONLY
    #$ECHO "\nHitachi firmware revision MKAOA5V0 is deprecated by firmware revision MK7OA6L0 and later. For details, see KB 2592."
    $ECHO "\nHitachi firmware revision MKAOA5V0 is deprecated by firmware revision MK7OA6L0 and later. For details, see KB 89129"
    $ECHO "This issue is resolved in firmware revision MK7OA6L0 and later."
    $ECHO "This issue affects only 108NL and X200 nodes using Hitachi 3TB disk drives. Model affected: Hitachi HUA723030ALA640 / MKAOA5V0"
  fi
  if [[ `grep "HUA723030ALA640" ${CLU_ALL_ISI_RADISH}| grep "MKAOA5V0"|wc -l` -ne 0 ]]; then
    #ALERT="Exact Same Issue could occur: Please refer to KB-2592"; PRINT_ALERT
    ALERT="Exact Same Issue could occur: Please refer to KB 89129"; PRINT_ALERT
    if [[ `grep BUF_TIMELOCK ${TEMP_PANIC_OUTPUT} 2>/dev/null |wc -l` -ne 0 ]]; then
      #WARNING="The following panic might be related to issue of KB-2592"; PRINT_WARNING
      WARNING="The following panic might be related to issue of KB 89129"; PRINT_WARNING
      cat ${TEMP_PANIC_OUTPUT}|egrep "\-\+$|[messages file]|BUF_TIMELOCK"
    fi
  fi
fi
rm -f ${TEMP_PANIC_OUTPUT} 2> /dev/null

#CATEGORY="disk"; BODY="KB-2592 - 1st : A change to the link rate : Rare PHY(physical link between SAS devices) communication failures"
CATEGORY="disk"; BODY="KB 89129 - 1st : A change to the link rate : Rare PHY(physical link between SAS devices) communication failures"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  WC_COUNT=`grep "changed linkrate" ${CLU_ALL_LOG_MSG}|wc -l`
  CMD="grep \"changed linkrate\" ${CLU_ALL_LOG_MSG}|wc -l"; EXEC_CMD_ONLY
  if [[ $WC_COUNT -ne 0 ]]; then
    $ECHO ""
    CMD="grep \"changed linkrate\" ${CLU_ALL_LOG_MSG}|sort -t: -k2|head -5"; EXEC_CMD_ONLY
    if [[ $WC_COUNT -gt 5 ]]; then
      if [[ $WC_COUNT -gt 10 ]]; then
        TAIL_COUNT=5
        $ECHO "\n...< might be snipped if count is over 10 >...\n"
      else
        $ECHO ""
        ((TAIL_COUNT=WC_COUNT-5))
      fi
      if [[ PREVIOUS_CURRENT_V4_V5 -eq 1 ]]; then
        CMD="grep \"changed linkrate\" ${CLU_ALL_LOG_MSG}|egrep -v \"${OLD_DATE_FORMAT}\"|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
      else
        CMD="grep \"changed linkrate\" ${CLU_ALL_LOG_MSG}|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
      fi
    fi
    $ECHO "\n  ====> Match 1 out of 3 : Please refer to KB-2592"
  fi
fi

#CATEGORY="disk"; BODY="KB-2592 - 2nd : DWS_LOST error : Rare PHY(physical link between SAS devices) communication failures"
CATEGORY="disk"; BODY="KB 89129 - 2nd : DWS_LOST error : Rare PHY(physical link between SAS devices) communication failures"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  WC_COUNT=`grep "DWS_LOST" ${CLU_ALL_LOG_MSG}|wc -l`
  CMD="grep \"DWS_LOST\" ${CLU_ALL_LOG_MSG}|wc -l"; EXEC_CMD_ONLY
  if [[ $WC_COUNT -ne 0 ]]; then
    $ECHO ""
    CMD="grep \"DWS_LOST\" ${CLU_ALL_LOG_MSG}|sort -t: -k2|head -5"; EXEC_CMD_ONLY
    if [[ $WC_COUNT -gt 5 ]]; then
      if [[ $WC_COUNT -gt 10 ]]; then
        TAIL_COUNT=5
        $ECHO "\n...< might be snipped if count is over 10 >...\n"
      else
        $ECHO ""
        ((TAIL_COUNT=WC_COUNT-5))
      fi
      if [[ PREVIOUS_CURRENT_V4_V5 -eq 1 ]]; then
        CMD="grep \"DWS_LOST\" ${CLU_ALL_LOG_MSG}|egrep -v \"${OLD_DATE_FORMAT}\"|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
      else
        CMD="grep \"DWS_LOST\" ${CLU_ALL_LOG_MSG}|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
      fi
    fi
    $ECHO "\n-----------------------------------------------"
    $ECHO "  checking drives encountering DWS_LOST error"
    $ECHO "-----------------------------------------------"
    CMD="grep \"DWS_LOST\" ${CLU_ALL_LOG_MSG}|awk '{print \$3,\$8,\$9}'|sort|uniq -c"; EXEC_CMD_ONLY
    #$ECHO "\n  ====> Match 2 out of 3 : Please refer to KB-2592"
    $ECHO "\n  ====> Match 2 out of 3 : Please refer to KB 89129"
  fi
fi

#CATEGORY="disk"; BODY="KB-2592 - 3rd : SATA initialization errors : Rare PHY(physical link between SAS devices) communication failures"
CATEGORY="disk"; BODY="KB 89129 - 3rd : SATA initialization errors : Rare PHY(physical link between SAS devices) communication failures"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  WC_COUNT=`grep "terminated ioc" ${CLU_ALL_LOG_MSG}|wc -l`
  CMD="grep \"terminated ioc\" ${CLU_ALL_LOG_MSG}|grep 31111000|wc -l"; EXEC_CMD_ONLY
  if [[ $WC_COUNT -ne 0 ]]; then
    $ECHO ""
    CMD="grep \"terminated ioc\" ${CLU_ALL_LOG_MSG}|grep 31111000|sort -t: -k2|head -5"; EXEC_CMD_ONLY
    if [[ $WC_COUNT -gt 5 ]]; then
      if [[ $WC_COUNT -gt 10 ]]; then
        TAIL_COUNT=5
        $ECHO "\n...< might be snipped if count is over 10 >...\n"
      else
        $ECHO ""
        ((TAIL_COUNT=WC_COUNT-5))
      fi
      if [[ PREVIOUS_CURRENT_V4_V5 -eq 1 ]]; then
        CMD="grep \"terminated ioc\" ${CLU_ALL_LOG_MSG}|grep 31111000|egrep -v \"${OLD_DATE_FORMAT}\"|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
      esle
        CMD="grep \"terminated ioc\" ${CLU_ALL_LOG_MSG}|grep 31111000|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
      fi
    fi
    #$ECHO "\n  ====> Match 3 out of 3 : Please refer to KB-2592"
    $ECHO "\n  ====> Match 3 out of 3 : Please refer to KB 89129"
  fi
fi

#CATEGORY="disk"; BODY="KB-2475 : 108NL components with NCQ enabled cause SCSI errors"
CATEGORY="disk"; BODY="KB 89106 : 108NL components with NCQ enabled cause SCSI errors"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `grep Product ${CLU_ALL}/isi_hw_status |grep 108NL|wc -l` -ge 1 ]]; then
    if [[ `grep "SATA NCQ enabled" ${CLU_ALL}/isi_mpsutil_ncq|wc -l` -ne 0 ]]; then
      #KB2475_108NL=0
      KB89106_108NL=0
      NCQ_ENABLED_NODE=`grep -l "SATA NCQ enabled" ${CLU_ALL}/isi_mpsutil_ncq|sed 's:/isi_mpsutil_ncq::'`
      for NODE in $NCQ_ENABLED_NODE
      do 
        NODE_108NL_COUNT=`grep Product ${NODE}/isi_hw_status|grep 108NL|wc -l`
        if [[ $NODE_108NL_COUNT -ge 1 ]]; then
          #KB2475_108NL=1
          KB89106_108NL=1
        fi
      done

      #if [[ $KB2475_108NL -eq 1 ]]; then
      if [[ $KB89106_108NL -eq 1 ]]; then
        CMD="grep \"SATA NCQ enabled\" ${CLU_ALL}/isi_mpsutil_ncq"; EXEC_CMD_ONLY
        #ALERT="108NL components with NCQ enabled cause SCSI errors : Please refer to KB-2475"; PRINT_ALERT
        ALERT="108NL components with NCQ enabled cause SCSI errors : Please refer to KB 89106"; PRINT_ALERT
        WARNING="Above NCQ enabled would be found another type of node, e.g. X200, S200\n         in that case, it would be no problem.\n         Please confirm node type from the following information."; PRINT_WARNING
        $ECHO "Some replacement hardware components (spare parts) for the 108NL ship from manufacturing with Native Command Queuing (NCQ) enabled.\nInstalling these components in 108NL nodes as configured, with NCQ enabled, may cause SCSI errors.\nTo ensure that 108NL nodes function properly, NCQ must be disabled on all 108NL components.\n"
        CMD="awk '{print FILENAME,\$0}' ${CLU_ALL}/isi_hw_status |grep Product| sed 's:/isi_hw_status: :g' |sed 's:${IN_DIR}/::g'|sort -t\"-\" -n -k2|grep 108NL"; EXEC_CMD_ONLY
      fi
    fi
  fi
fi

CATEGORY="disk"; BODY="Disk Health check"
CMD="grep -v HEALTHY ${CLU_ALL}/isi_devices"; EXEC_CMD

CATEGORY="disk"; BODY="DSR(Dynamic Sector Repair) Failure"
CMD="grep \"DSR\" ${CLU_ALL_LOG_MSG}|sort -t: -k2|wc -l"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `grep "DSR" ${CLU_ALL_LOG_MSG}|sort -t: -k2|wc -l` -ne 0 ]]; then
    #ALERT="DSR(Dynamic Sector Repair) Failure : Please refer to KB-407(How to address DSR failures)"; PRINT_ALERT
    ALERT="DSR(Dynamic Sector Repair) Failure : Please refer to KB 16645 (How to address DSR failures)"; PRINT_ALERT
    if [[ PREVIOUS_CURRENT_V4_V5 -eq 1 ]]; then
      CMD="grep \"DSR\" ${CLU_ALL_LOG_MSG}|egrep -v \"${OLD_DATE_FORMAT}\"|sort -t: -k2|tail -10"; EXEC_CMD_ONLY
      $ECHO ""
      CMD="grep \"DSR\" ${CLU_ALL_LOG_MSG}|grep -v \"DSR successfully repaired\"|egrep -v \"${OLD_DATE_FORMAT}\"|sort -t: -k2|tail -10"; EXEC_CMD_ONLY
    else
      CMD="grep \"DSR\" ${CLU_ALL_LOG_MSG}|sort -t: -k2|tail -10"; EXEC_CMD_ONLY
      $ECHO ""
      CMD="grep \"DSR\" ${CLU_ALL_LOG_MSG}|grep -v \"DSR successfully repaired\"|sort -t: -k2|tail -10"; EXEC_CMD_ONLY
    fi
  fi
fi

CATEGORY="disk"; BODY="IDI(Isilon Data Integrity) log check"
CMD="ls -al ${CLU_ALL_LOG}/idi.log"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  $ECHO ""
  #CMD="$GNU_GREP -o -E '[1-9]{1}:[[:xdigit:]]{4}+:[[:xdigit:]]{4}' ${CLU_ALL_LOG}/idi.log|sort|uniq -c"; EXEC_CMD_ONLY
  #CMD="$GNU_GREP -o -E '[1-9]{1}:[[:xdigit:]]{4}+:[[:xdigit:]]{4}::[[:xdigit:]]{1}+|[1-9]{1}:[[:xdigit:]]{4}+:[[:xdigit:]]{4}::HEAD' ${CLU_ALL_LOG}/idi.log|cut -d: -f2-6|sort|uniq -c"; EXEC_CMD_ONLY
  CMD="$GNU_GREP -oh -E '[0-9a-f]+:[0-9a-f]{4}:[0-9a-f]{4}[\:]*[0-9A-H]*' ${CLU_ALL_LOG}/idi.log|sort|uniq -c"; EXEC_CMD_ONLY
  #CMD="$GNU_GREP -oh -E '[0-9a-f]+:[0-9a-f]{4}:[0-9a-f]{4}::[0-9A-H]*' ${CLU_ALL_LOG}/idi.log|sort|uniq -c"; EXEC_CMD_ONLY
  if [[ $IS_ONEFS_version5 -eq 0 ]]; then
    if [[ `grep "Malformed block history" ${CLU_ALL_LOG}/idi.log | wc -l` -gt 0 ]]; then
      $ECHO ""
      CMD="grep \"Malformed block history\" ${CLU_ALL_LOG_MSG}|cut -d: -f8-9|cut -d' ' -f1-7|sort|uniq -c"; EXEC_CMD_ONLY
      $ECHO ""
      CMD="egrep \" ffb| bhv| mfb| mmb\" ${CLU_ALL_LOG}/idi.log|awk '{print \$5}'|sort|uniq -c"; EXEC_CMD_ONLY
    fi
  fi
fi

CATEGORY="disk"; BODY="IDI(Isilon Data Integrity) Failure"
CMD="grep \"IDI failure\" ${CLU_ALL_LOG_MSG}|sort -t: -k2|wc -l"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `grep "IDI failure" ${CLU_ALL_LOG_MSG}|wc -l` -ne 0 ]]; then
    if [[ PREVIOUS_CURRENT_V4_V5 -eq 1 ]]; then
      CMD="grep \"IDI failure\" ${CLU_ALL_LOG_MSG}|egrep -v \"${OLD_DATE_FORMAT}\"|sort -t: -k2|tail -50"; EXEC_CMD_ONLY
    else
      CMD="grep \"IDI failure\" ${CLU_ALL_LOG_MSG}|sort -t: -k2|tail -50"; EXEC_CMD_ONLY
    fi
    #ALERT="IDI Failure : Please refer to KB-780(Handling Isilon Data Integrity (IDI) errors)"; PRINT_ALERT
    ALERT="IDI Failure : Please refer to KB 89785 (Handling Isilon Data Integrity (IDI) errors)"; PRINT_ALERT
    ALERT="IDI failures indicate a potential problem with filesystem integrity"; PRINT_ALERT
  fi
fi

CATEGORY="disk"; BODY="ECC (Error Correction Code)"
CMD="grep \"ECC list\" ${CLU_ALL_LOG_MSG}|wc -l"; EXEC_CMD
$ECHO ""
if [[ $RUN_OR_NOT -eq 1 ]]; then
  WC_COUNT=`grep "ECC list" ${CLU_ALL_LOG_MSG}|wc -l`
  if [[ $WC_COUNT -ne 0 ]]; then
    CMD="grep \"ECC list\" ${CLU_ALL_LOG_MSG}|sort -t: -k2|head -5"; EXEC_CMD_ONLY
    if [[ $WC_COUNT -gt 5 ]]; then
      if [[ $WC_COUNT -gt 10 ]]; then
        TAIL_COUNT=5
        $ECHO "\n...< might be snipped if count is over 10 >...\n"
      else
        $ECHO ""
        ((TAIL_COUNT=WC_COUNT-5))
      fi
      if [[ PREVIOUS_CURRENT_V4_V5 -eq 1 ]]; then
        CMD="grep \"ECC list\" ${CLU_ALL_LOG_MSG}|egrep -v \"${OLD_DATE_FORMAT}\"|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
      else
        CMD="grep \"ECC list\" ${CLU_ALL_LOG_MSG}|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
      fi
    fi
    $ECHO ""
    if [[ $IS_ONEFS_version5 -eq 1 ]]; then
      CMD="grep \"ECC list\" ${CLU_ALL_LOG_MSG}|awk '{p1=index(\$0,\"da\");u=substr(\$0,p1,4);print \$5,u}'|sed \"s:\\:$: :\"|sort|uniq -c"; EXEC_CMD_ONLY
      NODE_DAnum=`grep "ECC list" ${CLU_ALL_LOG_MSG}|awk '{p1=index($0,"da");u=substr($0,p1,4);print $5,u}'|sed "s:\:$: :"|sort|uniq -c|awk '{print $2,$3}'|awk -F'(' '{p1=index($0,"da");u=substr($0,p1,4);print $1,u}'`
    else
      if [[ PREVIOUS_CURRENT_V4_V5 -eq 1 ]]; then
        CMD="grep \"ECC list\" ${CLU_ALL_LOG_MSG}|egrep -v \"${OLD_DATE_FORMAT}\"|awk '{p1=index(\$0,\"da\");u=substr(\$0,p1,4);print \$3,u}'|sed \"s:\\:$: :\"|sort|uniq -c"; EXEC_CMD_ONLY
        NODE_DAnum=`grep "ECC list" ${CLU_ALL_LOG_MSG}|egrep -v "${OLD_DATE_FORMAT}"|awk '{p1=index($0,"da");u=substr($0,p1,4);print $3,u}'|sed "s:\:$: :"|sort|uniq -c|awk '{print $2,$3}'|awk -F'(' '{p1=index($0,"da");u=substr($0,p1,4);print $1,u}'`
      else
        CMD="grep \"ECC list\" ${CLU_ALL_LOG_MSG}|awk '{p1=index(\$0,\"da\");u=substr(\$0,p1,4);print \$3,u}'|sed \"s:\\:$: :\"|sort|uniq -c"; EXEC_CMD_ONLY
        NODE_DAnum=`grep "ECC list" ${CLU_ALL_LOG_MSG}|awk '{p1=index($0,"da");u=substr($0,p1,4);print $3,u}'|sed "s:\:$: :"|sort|uniq -c|awk '{print $2,$3}'|awk -F'(' '{p1=index($0,"da");u=substr($0,p1,4);print $1,u}'`
      fi
    fi
    $ECHO "\n==========================================================================="
    $ECHO "  The following information might be different from log on messages file."
    $ECHO "  That is, da## could be changed, even Lnum is persistent."
    $ECHO "==========================================================================="
    t_ON_OFF=1; 
    for I in $NODE_DAnum
    do 
      if [[ $t_ON_OFF -eq 1 ]]; then
        t_NODE=$I
        t_ON_OFF=0; 
      else
        t_DAnum=$I
        grep da ${CLU_ALL}/isi_devices|grep "${t_NODE}/"|grep "${t_DAnum} "
        t_ON_OFF=1; 
      fi
    done
  fi
fi

CATEGORY="disk"; BODY="Smart-failing drive because ECC list length is at or above 30"
CMD="egrep \"Smart-failing drive.*ECC list length\" ${CLU_ALL_LOG_MSG}|wc -l"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  WC_COUNT=`egrep "Smart-failing drive.*ECC list length" ${CLU_ALL_LOG_MSG}|wc -l`
  if [[ $WC_COUNT -ne 0 ]]; then
    CMD="$GNU_GREP -A5 -e \"Smart-failing drive.*ECC list length\" ${CLU_ALL_LOG_MSG}| egrep \"Smart-failing drive|new group\""; EXEC_CMD_ONLY
    WARNING="OneFS tried to SmartFail above drive(s) due to the ECC length reached at 30"; PRINT_WARNING
  fi
fi

CATEGORY="disk"; BODY="Smart-failing drive because of user request"
CMD="egrep \"Smart-failing drive.*user request\" ${CLU_ALL_LOG_MSG}|wc -l"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  WC_COUNT=`egrep "Smart-failing drive.*user request" ${CLU_ALL_LOG_MSG}|wc -l`
  if [[ $WC_COUNT -ne 0 ]]; then
    CMD="$GNU_GREP -A5 -e \"Smart-failing drive.*user request\" ${CLU_ALL_LOG_MSG}| egrep \"Smart-failing drive|new group\""; EXEC_CMD_ONLY
    WARNING="OneFS tried to SmartFail above drive(s) because of user request"; PRINT_WARNING
  fi
fi

CATEGORY="disk"; BODY="Unrecovered read"
CMD="grep \"Unrecovered read\" ${CLU_ALL_LOG_MSG}|wc -l"; EXEC_CMD
$ECHO ""
if [[ $RUN_OR_NOT -eq 1 ]]; then
  WC_COUNT=`grep "Unrecovered read" ${CLU_ALL_LOG_MSG}|wc -l`
  if [[ $WC_COUNT -ne 0 ]]; then
    if [[ $IS_ONEFS_version5 -eq 1 ]]; then
      CMD="grep \"Unrecovered read\" ${CLU_ALL_LOG_MSG}|grep "....-..-..T"|egrep -v \"${OLD_DATE_FORMAT}\"|sort -t: -k2|head -5"; EXEC_CMD_ONLY
    else
      CMD="grep \"Unrecovered read\" ${CLU_ALL_LOG_MSG}|grep "....-..-..T"|sort -t: -k2|head -5"; EXEC_CMD_ONLY
    fi
    if [[ $WC_COUNT -gt 5 ]]; then
      if [[ $WC_COUNT -gt 10 ]]; then
        TAIL_COUNT=5
        $ECHO "\n...< might be snipped if count is over 10 >...\n"
      else
        $ECHO ""
        ((TAIL_COUNT=WC_COUNT-5))
      fi
      if [[ PREVIOUS_CURRENT_V4_V5 -eq 1 ]]; then
        CMD="grep \"Unrecovered read\" ${CLU_ALL_LOG_MSG}|egrep -v \"${OLD_DATE_FORMAT}\"|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
      else
        CMD="grep \"Unrecovered read\" ${CLU_ALL_LOG_MSG}|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
      fi
    fi
    $ECHO ""
    if [[ $IS_ONEFS_version5 -eq 1 ]]; then
      CMD="grep \"Unrecovered read\" ${CLU_ALL_LOG_MSG}|awk '{print \$5,\$7}'|sort|uniq -c"; EXEC_CMD_ONLY
    else
      if [[ PREVIOUS_CURRENT_V4_V5 -eq 1 ]]; then
        CMD="grep \"Unrecovered read\" ${CLU_ALL_LOG_MSG}|egrep -v \"${OLD_DATE_FORMAT}\"|awk '{print \$3,\$5}'|sort|uniq -c"; EXEC_CMD_ONLY
      else
        CMD="grep \"Unrecovered read\" ${CLU_ALL_LOG_MSG}|awk '{print \$3,\$5}'|sort|uniq -c"; EXEC_CMD_ONLY
      fi
    fi
  fi
fi

CATEGORY="stall"; BODY="Count of Disk Stalled messages"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ $IS_ONEFS_version5 -eq 1 ]]; then
    ALERT="Disk Stall messages might be different on OneFS v5.X."; PRINT_ALERT
    CMD="grep \"stalled:\" ${CLU_1ST_LOG_MSG}|wc -l"; EXEC_CMD_ONLY
    if [[ `grep "stalled:" ${CLU_1ST_LOG_MSG}|wc -l` -ne 0 ]]; then
      CMD="grep \"stalled:\" ${CLU_1ST_LOG_MSG}|awk '{u=substr(\$0,index(\$0,\"stalled:\"),20);print u}'|sort|uniq -c|sed 's:}::'"; EXEC_CMD_ONLY
    fi
  else
    CMD="grep \"changed to stalled\" ${CLU_1ST_LOG_MSG}|wc -l"; EXEC_CMD_ONLY
  fi

  if [[ `grep "changed to stalled" ${CLU_1ST_LOG_MSG}|wc -l` -ne 0 ]]; then
    CMD="egrep \"HUA723030ALA640\" ${CLU_ALL_ISI_RADISH}| awk '{print \$4,\$5,\$6}'|sort|uniq -c"; EXEC_CMD_ONLY
    if [[ `egrep "HUA723030ALA640" ${CLU_ALL_ISI_RADISH}|grep MKAOA5V0|wc -l` -ne 0 ]]; then
      #$ECHO "\nHitachi firmware revision MKAOA5V0 is deprecated by firmware revision MK7OA6L0 and later. For details, see KB 2592."
      $ECHO "\nHitachi firmware revision MKAOA5V0 is deprecated by firmware revision MK7OA6L0 and later. For details, see KB 89129."
      $ECHO "You might become aware of this issue if a Hitachi 3TB drive(HUA723030ALA640) stalls numerous times in a relatively brief period."
      $ECHO "Please compare Firmware version above : This issue is resolved in firmware revision MK7OA6L0 and later."
      #ALERT="KB-2017 could occur \"Rare drive stalls on Hitachi 3TB disk drives\""; PRINT_ALERT
      ALERT="KB 88930 could occur \"Rare drive stalls on Hitachi 3TB disk drives\""; PRINT_ALERT
    fi

    if [[ `egrep "HUA722020ALA330|HUA722010CLA330" ${CLU_ALL_ISI_RADISH}|wc -l` -ne 0 ]]; then
      $ECHO ""
      CMD="egrep \"HUA722020ALA330|HUA722010CLA330\" ${CLU_ALL_ISI_RADISH}| awk '{print \$4,\$5,\$6}'|sort|uniq -c"; EXEC_CMD_ONLY
      CMD="awk '{print FILENAME,\$0}' ${CLU_ALL}/isi_hw_status |grep Product| sed 's:/isi_hw_status: :g' |sed 's:${IN_DIR}/::g'"; EXEC_CMD_ONLY
      $ECHO "\nThis issue applies only to Hitachi disk drives installed in 36NL, 36000X, 72NL, and 72000X 4U Isilon platforms that shipped before July 2011."
      $ECHO "The Hitachi 3TB drives, which are used in Isilon 108NL platforms, are from the Mars family of drives, which are unaffected by vibration sensitivity issues."
      $ECHO "Hitachi 500GB drives did not ship in 4U Isilon nodes during this period."
      #WARNING="vibration sensitivity Issue could occur : Please refer to KB-1992"; PRINT_WARNING
      WARNING="vibration sensitivity Issue could occur : Please refer to KB 88905"; PRINT_WARNING
    fi

    BODY="Per node and disks: Disk Stalled messages: drive X means lnum X"
    CMD="grep \"changed to stalled\" ${CLU_1ST_LOG_MSG}|awk '{p1=index(\$0,\"(node\");p2=index(\$0,\"ed)\");u=substr(\$0,p1,p2-p1+3);print u}'|sort -n -k2 -k4|uniq -c|tee ${TEMP_FILE}"; EXEC_CMD
    STALL_NODE_DRIVE_LIST=`cat ${TEMP_FILE}|awk '{print $3, $5}'`
    $ECHO ""
    t_ON_OFF=1;
    NODE_ALEADY_REPLACED=0
    for I in $STALL_NODE_DRIVE_LIST
    do
      if [[ $t_ON_OFF -eq 1 ]]; then
        CONVERT_NODE_ID_TO_NODENAME=`grep "^${I} " ${IN_DIR}/nodes_info|awk '{print $3}'`
        if [[ ${CONVERT_NODE_ID_TO_NODENAME}_x = "_x" ]]; then
          NODE_ALEADY_REPLACED=1
        fi
        t_NODE=${I}
        t_ON_OFF=0;
      else
        t_Lnum=$I
        if [[ ${NODE_ALEADY_REPLACED} -eq 1 ]]; then
          $ECHO "  [1;33m=> NODE ID [${t_NODE}] might be replaced[0m"
        else
          $ECHO "\n  NODE_ID[${t_NODE}], NODE[${CONVERT_NODE_ID_TO_NODENAME}], Lnum[${t_Lnum}] <= Drive \"replaced\" or not ?"
          grep da ${CLU_ALL}/isi_devices|grep "${CONVERT_NODE_ID_TO_NODENAME}/"|grep "Lnum ${t_Lnum} "
          if [[ $? -ne 0 ]]; then
            $ECHO "    [42;30m-> NODE,[${CONVERT_NODE_ID_TO_NODENAME}] Lnum,[${t_Lnum}] drive NOT found, might be already replaced[0m"
          fi
        fi
        t_ON_OFF=1;
        NODE_ALEADY_REPLACED=0
      fi
    done

##################################
###############################
############################
#########################
######################         Logic for making map of node and disk stall Count
###################
################
#############
##########

    $ECHO "\n::::::::::::::::::::::::::::::::::::::::::::::::::::::"
    $ECHO "   Now ... Creating file for drive stall Map ..."
    $ECHO "::::::::::::::::::::::::::::::::::::::::::::::::::::::\n"

    #CMD="grep \"stalled:\" ${CLU_1ST_LOG_MSG}|wc -l"; EXEC_CMD_ONLY
    #CMD="head -1000 ${CLU_1ST_LOG_MSG}|grep \"^....-..-..T\"|sort|head -1|awk '{print \$1}'"; EXEC_CMD_ONLY
    STALL_SINCE_TIMESTAMP=`head -1000 ${CLU_1ST_LOG_MSG}|grep "^....-..-..T"|sort|head -1|awk '{print $1}'`
    $ECHO "${TEXT_YELLOW}===============================================================================================${COLOR_RESET}"
    $ECHO "${TEXT_YELLOW}  The following \"Drive Stall Map\" is${COLOR_RESET}"
    $ECHO "${TEXT_YELLOW}  Since \"${STALL_SINCE_TIMESTAMP}\" ; Based on [ ${CLU_1ST_LOG_MSG} ] file(s) ${COLOR_RESET}"
    $ECHO "${TEXT_YELLOW}===============================================================================================${COLOR_RESET}"

    STALL_NODE_DRIVE_COUNT_LIST=`cat ${TEMP_FILE}|awk '{print $3, $5, $1}'|grep "^[0-9]"`
    t_ON_OFF_1=1;
    t_ON_OFF_2=1;
    NODE_ALEADY_REPLACED=0
    DRIVE_NOT_FOUND=0

    for I in $STALL_NODE_DRIVE_COUNT_LIST
    do
      #- Node (LNN) -#
      if [[ $t_ON_OFF_1 -eq 1 ]]; then
        CONVERT_NODE_ID_TO_NODENAME=`grep "^${I} " ${IN_DIR}/nodes_info|awk '{print $3}'`
        if [[ ${CONVERT_NODE_ID_TO_NODENAME}_x = "_x" ]]; then
          NODE_ALEADY_REPLACED=1
        fi
        t_NODE=${I}
        t_ON_OFF_1=0;
        #$ECHO "1: $t_NODE"

      #- Driv (Lnum) -#
      elif [[ $t_ON_OFF_2 -eq 1 ]]; then
        t_Lnum=$I
        if [[ ${NODE_ALEADY_REPLACED} -eq 1 ]]; then
          echo "${t_NODE}:${t_Lnum}:R" >> ${TEMP_FILE_2}
        else
          CONFIRMED_LNUM=`grep da ${CLU_ALL}/isi_devices|grep "${CONVERT_NODE_ID_TO_NODENAME}/"|grep "Lnum ${t_Lnum} "|awk '{print $5}'`
          #grep da ${CLU_ALL}/isi_devices|grep "${CONVERT_NODE_ID_TO_NODENAME}/"|grep "Lnum ${t_Lnum} " >/dev/null 2&>1

          #- added on Oct-21-2013, in case awk command does not have result, 
          #- it set value to 0(zero), so it set "Lnum 0" as existing drive
          if [[ ${t_Lnum} -eq 0 ]]; then
            CONFIRMED_LNUM_COUNT=`grep da ${CLU_ALL}/isi_devices|grep "${CONVERT_NODE_ID_TO_NODENAME}/"|grep "Lnum ${t_Lnum} "|awk '{print $5}'|wc -l`
            if [[ ${CONFIRMED_LNUM_COUNT} -eq 0 ]]; then
              echo "${t_NODE}:${t_Lnum}:R" >> ${TEMP_FILE_2}
              DRIVE_NOT_FOUND=1
            fi
          else
            if [[ ${CONFIRMED_LNUM} -ne ${t_Lnum} ]]; then
              echo "${t_NODE}:${t_Lnum}:R" >> ${TEMP_FILE_2}
              DRIVE_NOT_FOUND=1
            else
              DRIVE_NOT_FOUND=0
            fi
          fi
        fi
        t_ON_OFF_2=0;
        NODE_ALEADY_REPLACED=0
        #$ECHO "2: $t_Lnum"
      #- Count of drvie stall -#
      else
        t_Count=$I
        #$ECHO "DRIVE_NOT_FOUND : [$DRIVE_NOT_FOUND]"
        if [[ $DRIVE_NOT_FOUND -ne 1 ]]; then
          echo "${t_NODE}:${t_Lnum}:${t_Count}" >> ${TEMP_FILE_2}
          DRIVE_NOT_FOUND=0
        fi
        t_ON_OFF_1=1;
        t_ON_OFF_2=1;
        #$ECHO "3: $t_Count"
      fi
    done

    #$ECHO "\nLegend : R:\"Replaced\", -:\"Zero Stall or Empty\", 999:\"over 999 times\", "
    $ECHO "\nLegend : [47;30m E [0m:\"Empty\", [43;30m R [0m:\"Replaced\", [42;30m - [0m:\"Zero Stall\", [41;33m999[0m:\"over 999 times\""
    $ECHO "+---+----++-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+"
    $ECHO "|   |    ||                                                                                     Lnum                                                                                      |"
    $ECHO "| ID| LNN|+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+"
    $ECHO "|   |    ||  0|  1|  2|  3|  4|  5|  6|  7|  8|  9| 10| 11| 12| 13| 14| 15| 16| 17| 18| 19| 20| 21| 22| 23| 24| 25| 26| 27| 28| 29| 30| 31| 32| 33| 34| 35| 36| 37| 38| 39| 40| 41| 42| 43|"
    $ECHO "+---+----++---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+"
    LNUM_FOUND=0
    ###LAST_NODE_ID=`tail -1 ${TEMP_FILE_2}|awk -F: '{print $1}'`
    LAST_NODE_ID=`cat ${IN_DIR}/nodes_info | sort -n | tail -1 | awk '{print $1}'`
    ((LAST_NODE_ID=LAST_NODE_ID+1))

    for (( NODE_ID = 1 ; NODE_ID < LAST_NODE_ID ; NODE_ID += 1 ))
    do
      printf "|%3s|" ${NODE_ID}
      CONVERT_LNN=`grep "^${NODE_ID} " ${IN_DIR}/nodes_info|awk '{print $4}'`
      if [[ ${CONVERT_LNN}X == "X" ]]; then
        printf "[43;30m%3s [0m||" "R"
      else
        printf "%3s ||" ${CONVERT_LNN}
      fi

      NODE_NAME=`grep "^${NODE_ID} " ${IN_DIR}/nodes_info|awk '{print $3}'`

      ###- added after getting comment from Jung-ho Park.
      if [[ $NODE_NAME"X" == "X" ]]; then
        MAX_LNUM=-1
      else
        if [[ -f ${IN_DIR}/${NODE_NAME}/isi_devices ]]; then
          #- Accelerator does not have valid Lnum -#
          if [[ `cat ${IN_DIR}/${NODE_NAME}/isi_devices 2>/dev/null |sed 1d| grep -v "Lnum N/A"|wc -l` -ne 0 ]]; then
            MAX_LNUM=`cat ${IN_DIR}/${NODE_NAME}/isi_devices 2>/dev/null |sed 1d| grep -v "Lnum N/A"|sort -n -k 4 | tail -1 | awk '{print $4}'`
          else
            MAX_LNUM=-1
          fi
          #- Accelerator does not have valid Lnum -#
        else
          MAX_LNUM=50
        fi
      fi
      ###- added after getting comment from Jung-ho Park.

      for (( LNUM = 0 ; LNUM < 44 ; LNUM += 1 ))
      do
        ALL_READ_LINE=`grep "^${NODE_ID}:" ${TEMP_FILE_2}`
        if [[ $LNUM -gt $MAX_LNUM ]]; then
          printf "[47;30m%3s[0m|" " E "

        ###if [[ $ALL_READ_LINE"X" == "X" ]]; then
        #- logic for some drives changed, but no stall in this node.
        elif [[ $ALL_READ_LINE"X" == "X" ]]; then
          ###- logic for drive already replaced but no drive stall events
          #    need to " R " instead of " E ", (added on Jul-17-2013)
          if [[ `grep "\[HEALTHY\]" ${IN_DIR}/${NODE_NAME}/isi_devices 2>/dev/null|grep "Lnum ${LNUM} "|wc -l` -eq 0 ]]; then
            printf "[43;30m%3s[0m|" " R "
          else
            printf "[42;30m%3s[0m|" " - "
          fi
          ###- logic for drive already replaced but no drive stall events
        #- logic for some drives changed, but no stall in this node.

        elif [[ $LNUM -gt `grep "^${NODE_ID}:" ${TEMP_FILE_2}|tail -1|awk -F: '{print $2}'` && $LNUM -ne 43 ]]; then
          #out# printf "[42;30m%3s[0m|" " - "
          #    need to " R " instead of " - ", (added on Jul-28-2013)
          if [[ `grep "\[HEALTHY\]" ${IN_DIR}/${NODE_NAME}/isi_devices 2>/dev/null|grep "Lnum ${LNUM} "|wc -l` -eq 0 ]]; then
            printf "[43;30m%3s[0m|" " R "
          else
            printf "[42;30m%3s[0m|" " - "
          fi

        else
          for LineStr in ${ALL_READ_LINE}
          do
            READ_NODE_ID=`echo $LineStr|awk -F: '{print $1}'`
            READ_LNUM=`echo $LineStr|awk -F: '{print $2}'`
            READ_COUNT=`echo $LineStr|awk -F: '{print $3}'`

            if [[ $READ_NODE_ID -eq $NODE_ID && $READ_LNUM -eq $LNUM ]]; then
              if [[ ${READ_COUNT} -ge 999 ]]; then
                printf "[41;33m%3s[0m|" "999"
              elif [[ ${READ_COUNT} == "R" ]]; then
                printf "[43;30m%3s[0m|" " R "
              else
                if [[ ${READ_COUNT} -ge 10 ]]; then
                  printf "[41;33m%3s[0m|" ${READ_COUNT}
                else
                  printf "%3s|" ${READ_COUNT}
                fi
              fi
              LNUM_FOUND=1
              break
            fi
          done # READ_LINE #

          if [[ LNUM_FOUND -ne 1 ]]; then
            ###- logic for drive already replaced but no drive stall events
            #    need to " R " instead of " E ", (added on Jul-17-2013)
            if [[ `grep "\[HEALTHY\]" ${IN_DIR}/${NODE_NAME}/isi_devices 2>/dev/null|grep "Lnum ${LNUM} "|wc -l` -eq 0 ]]; then
              printf "[43;30m%3s[0m|" " R "
            else
              printf "[42;30m%3s[0m|" " - "
            fi
            ###- logic for drive already replaced but no drive stall events
          fi
          LNUM_FOUND=0
        fi

        if [[ $LNUM -eq 43 ]]; then
          if [[ $MAX_LNUM -gt 43 ]]; then
            printf "... Max[$MAX_LNUM]"
          fi
          printf "\n"
          $ECHO "+---+----++---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+"
        fi
      done # LNUM #
    done # NODE_ID #

#
# END OF Logic for making Map of node and disk stall Count
#
#====================================================================

    rm -f ${TEMP_FILE}
    rm -f ${TEMP_FILE_2}

    BODY="Frequency by date: Disk Stalled messages"
    if [[ `ls -1 ${CLU_1ST_LOG_MSG}|wc -l` -eq 1 ]]; then
      CMD="grep \"changed to stalled\" ${CLU_1ST_LOG_MSG}|cut -d\"T\" -f1|uniq -c|tee ${TEMP_FILE}"; EXEC_CMD
    else
      CMD="grep \"changed to stalled\" ${CLU_1ST_LOG_MSG}|cut -d: -f2|cut -d\"T\" -f1|cut -d":" -f2|sort|uniq -c|tee ${TEMP_FILE}"; EXEC_CMD
    fi

    BODY="Frequency by date and Disks: drive X means lnum X";PRINT_HEAD_TAIL
    if [[ `ls -1 ${CLU_1ST_LOG_MSG}|wc -l` -eq 1 ]]; then
      # messages count is one
      for I in `cat ${TEMP_FILE}|awk '{print $2}'`; do echo " [ $I ]"; grep "changed to stalled" ${CLU_1ST_LOG}/messages|grep ${I}T|awk '{p1=index($0,"(node");p2=index($0,"ed)");u=substr($0,p1,p2-p1+3);print u}'|sort -n -k2 -k4|uniq -c;done
    else
      # messages count is more than one
      for I in `cat ${TEMP_FILE}|awk '{print $2}'`; do echo " [ $I ]"; cat ${CLU_1ST_LOG_MSG}|grep "changed to stalled"|grep ${I}T|awk '{p1=index($0,"(node");p2=index($0,"ed)");u=substr($0,p1,p2-p1+3);print u}'|sort -n -k2 -k4|uniq -c;done
    fi
    rm -f ${TEMP_FILE}

    BODY="Parameter relating to Disk Stall"; PRINT_HEAD_TAIL
    CMD="grep \"hw.disk_event.thresh.slowacc_usec\" ${CLU_ALL}/hw.disk_event|awk -F: '{print \$2,\$3}'|sort|uniq -c"; EXEC_CMD_ONLY
    $ECHO ""
    CMD="grep \"hw.disk_event.thresh.slowfreq_usec\" ${CLU_ALL}/hw.disk_event|awk -F: '{print \$2,\$3}'|sort|uniq -c"; EXEC_CMD_ONLY
    $ECHO ""
    CMD="grep \"hw.disk_event.thresh.slowfreq_max\" ${CLU_ALL}/hw.disk_event|awk -F: '{print \$2,\$3}'|sort|uniq -c"; EXEC_CMD_ONLY
    $ECHO ""
    CMD="grep \"hw.disk_event.thresh.slowfreq_history\" ${CLU_ALL}/hw.disk_event|awk -F: '{print \$2,\$3}'|sort|uniq -c"; EXEC_CMD_ONLY
  fi

  if [[ `egrep "hw.disk_event.thresh.slowacc_single_act: [01]|hw.disk_event.thresh.slowfreq_act: [01]" ${CLU_ALL}/hw.disk_event|wc -l` -ne 0 ]]; then
    WARNING="** disabled \"drive stall\" triggered by slow I/O through below parameters **"; PRINT_WARNING
    if [[ `egrep "hw.disk_event.thresh.slowacc_single_act: [01]" ${CLU_ALL}/hw.disk_event|wc -l` -ne 0 ]]; then
      CMD="egrep \"hw.disk_event.thresh.slowacc_single_act: [01]\" ${CLU_ALL}/hw.disk_event|cut -d: -f2-4|sort|uniq -c"; EXEC_CMD_ONLY
      $ECHO "\n   \"hw.disk_event.thresh.slowacc_single_act\" means:\n   0=ignore, 1=warn, 2=softfail, 3=hardfail, 4=abort I/Os (default; puts drive into stalled state)"
    fi
    if [[ `egrep "hw.disk_event.thresh.slowfreq_act: [01]" ${CLU_ALL}/hw.disk_event|wc -l` -ne 0 ]]; then
      $ECHO ""
      CMD="egrep \"hw.disk_event.thresh.slowfreq_act: [01]\" ${CLU_ALL}/hw.disk_event|cut -d: -f2-4|sort|uniq -c"; EXEC_CMD_ONLY
      $ECHO "\n   \"hw.disk_event.thresh.slowfreq_act\" means:\n   0=ignore, 1=warn, 2=softfail, 3=hardfail, 4=abort I/Os (default; puts drive into stalled state)"
    fi
  fi

  #BODY="Disk Stall relating \"LSI 2008 SAS Controller\" : KB2591"
  BODY="Disk Stall relating \"LSI 2008 SAS Controller\" : KB 89128"
  CMD=""; EXEC_CMD
  if [[ `ls -1 ${CLU_ALL}/pciconf | wc -l` -ne 0 ]]; then
    CMD="grep \"rev=0x02\" ${CLU_ALL}/pciconf|grep mps0"; EXEC_CMD_ONLY
    if [[ `eval $CMD | wc -l` -ne 0 ]]; then
      #ALERT="               Please refer to KB-2591               "; PRINT_ALERT
      ALERT="               Please refer to KB 89128              "; PRINT_ALERT
      $ECHO "*** In rare circumstances, certain Isilon IQ nodes experience numerous drive stalls.\n    All in-process file system operations on that node are aborted,\n    and all data on that node becomes unavailable for approximately 5-10 seconds.\n    There is no risk of data loss, nor is data integrity diminished in any way.\n    This issue might occur on any Isilon IQ 108NL, S200, and X200 system that shipped prior to August 2011."
    $ECHO ""
    CMD="awk '{print FILENAME,\$0}' ${CLU_ALL}/isi_hw_status |grep Product| sed 's:/isi_hw_status: :g' |sed 's:${IN_DIR}/::g'|sort -t\"-\" -n -k2|egrep -i \"108NL|s200|x200\""; EXEC_CMD_ONLY
    fi
  else
    $ECHO ""
    $ECHO "! pciconf Files NOT exist !"
  fi
fi

CATEGORY="stall"; BODY="SmartFail due to the Disk Stall"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  CMD="egrep \"Softfailing|Smart-failing drive.*drive failed stalled eval\" ${CLU_ALL_LOG_MSG} | sort -t: -k2 | tee ${TEMP_FILE}"; EXEC_CMD_ONLY
  if [[ `cat ${TEMP_FILE} | wc -l` -ge 1 ]]; then
    WARNING="OneFS tried to SmartFail above drive(s) due to the cumulative Disk stall time exceeded 3 hours (10800 secs)"; PRINT_WARNING
  fi
  rm -f ${TEMP_FILE}
fi

rm -f ${TEMP_FILE}
CATEGORY="snapshot"; BODY="log_queue_states : relating to the SnapshotDelete";
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ $IS_ONEFS_version5 -eq 1 ]]; then
    CMD="ls -al ${CLU_ALL_LOG}/isi_job_d.log"; EXEC_CMD_ONLY
    $ECHO "\n !!! NO isi_job_d.log file on OneFS v5.X !!!\n"
  else
    EXIST_log_queue_states=0
    for EACH_NODE in $CLUSTER_NODE
    do
      BODY="${EACH_NODE} : log_queue_states"; PRINT_HEAD_LOOP
      CMD="grep \"log_queue_states\" ${IN_DIR}/${EACH_NODE}/varlog.tar/log/isi_job_d.log|tail -2"; EXEC_CMD_ONLY
      grep "log_queue_states" ${IN_DIR}/${EACH_NODE}/varlog.tar/log/isi_job_d.log 2> /dev/null |tail -1 >> ${TEMP_FILE}
    done
    if [[ ! -z ${TEMP_FILE} ]]; then
      READY=`cat ${TEMP_FILE} |awk '{ total += $9 } END { print total }'`
      WORKING=`cat ${TEMP_FILE} |awk '{ total += $11 } END { print total }'`
      STOPPED=`cat ${TEMP_FILE} |awk '{ total += $13 } END { print total }'`
      SUSPENDED=`cat ${TEMP_FILE} |awk '{ total += $15 } END { print total }'`
      if [[ $WORKING -le 1 && $READY -ge 10 ]]; then
        WARNING="Worker - READY[$READY] / WORKING[$WORKING] / STOPPED[$STOPPED] / SUSPENDED [$SUSPENDED] from log_queue_states"; PRINT_WARNING
        if [[ `grep "delete pending" ${IN_DIR}/local/snapshot_usage|wc -l` -ne 0 ]]; then
          FIXED_ONEFS_V655X="6.5.5.6"
          F_COMPARE_CURRENT_VERSION_AND_FIXED_VERSION
          if [[ $THIS_ISSUE_NOT_FIXED_IN_THIS_CLUSTER -eq 1 ]]; then
            $ECHO "   ==> Bug 89735, Already fixed in this version <=="
          else
            #$ECHO "==> Display it, need to upgrade <=="
            PRINT_CURRENT_ONEFS_VERSION
            #ALERT="Please refer to Bug 89735 / KB-3643 / Resolved on and after OneFS 6.5.5.6"; PRINT_ALERT
            ALERT="Please refer to Bug 89735 / KB 89516 / Resolved on and after OneFS 6.5.5.6"; PRINT_ALERT
          fi
        fi
      else
        BODY="Worker - READY[$READY] / WORKING[$WORKING] / STOPPED[$STOPPED] / SUSPENDED [$SUSPENDED] from log_queue_states"; PRINT_HEAD_TAIL
      fi
    fi
    rm -f ${TEMP_FILE}
  fi
fi

CATEGORY="snapshot"; BODY="SnapShotDelete Pending"
CMD="grep \"delete pending\" ${IN_DIR}/local/snapshot_usage|wc -l"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ -a ${IN_DIR}/local/snapshot_usage ]]; then
    SNAPSHOT_PENDING=`eval $CMD`
    if [[ $SNAPSHOT_PENDING -ne 0 ]]; then
      $ECHO ""
      CMD="$GNU_GREP -A3 \"SnapshotDelete\" ${IN_DIR}/local/isi_job_status | head -3"; EXEC_CMD_ONLY
      $ECHO ""
      if [[ $SNAPSHOT_PENDING -le 10 ]]; then
        CMD="grep \"delete pending\" ${IN_DIR}/local/snapshot_usage"; EXEC_CMD_ONLY
      else
        CMD="grep \"delete pending\" ${IN_DIR}/local/snapshot_usage|head -5"; EXEC_CMD_ONLY
        $ECHO "\n...< might be snipped if count is over 10 >...\n"
        CMD="grep \"delete pending\" ${IN_DIR}/local/snapshot_usage|tail -5"; EXEC_CMD_ONLY
        $ECHO "Total Usage -------------------------------------------- ---------- -----------"
        tail -1 ${IN_DIR}/local/snapshot_usage
      fi
    fi
  else
    $ECHO "! snapshot_usage File NOT Exist !"
  fi
fi

CATEGORY="mesg"; BODY="LOG_EMERG <#.0> from all nodes all messages files"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  CMD="egrep \"<[0-9].*\.0>\" ${CLU_ALL_LOG_MSG}|egrep -v \"\.7>.*<Version|last message repeated|<24.0>\"|wc -l"; EXEC_CMD_ONLY
  if [[ $IS_ONEFS_version5 -eq 1 ]]; then
    CMD="egrep \"<[0-9].*\.0>\" ${CLU_1ST_LOG}/messages|egrep -v \"\.7>.*<Version|last message repeated|<24.0>\"|tail -50"; EXEC_CMD_ONLY
  else
    CMD="egrep \"<[0-9].*\.0>\" ${CLU_ALL_LOG_MSG}|egrep -v \"\.7>.*<Version|last message repeated|<24.0>\"|sort -t: -k2|tail -50"; EXEC_CMD_ONLY
  fi

  CATEGORY="mesg"; BODY="LOG_ALERT <#.1> from all nodes all messages files"
  CMD="egrep \"<[0-9].*\.1>\" ${CLU_ALL_LOG_MSG}|egrep -v \"\.7>.*<Version|last message repeated\"|wc -l"; EXEC_CMD
  if [[ $IS_ONEFS_version5 -eq 1 ]]; then
    CMD="egrep \"<[0-9].*\.1>\" ${CLU_1ST_LOG}/messages|egrep -v \"\.7>.*<Version|last message repeated\"|tail -50"; EXEC_CMD_ONLY
  else
    CMD="egrep \"<[0-9].*\.1>\" ${CLU_ALL_LOG_MSG}|egrep -v \"\.7>.*<Version|last message repeated\"|sort -t: -k2|tail -50"; EXEC_CMD_ONLY
  fi

  CATEGORY="mesg"; BODY="LOG_CRIT <#.2> from 1st node current messages files"
  CMD="egrep \"<[0-9].*\.2>\" ${CLU_1ST_LOG}/messages|egrep -v \"\.7>.*<Version|last message repeated|sendmail\"|wc -l"; EXEC_CMD
  CMD="egrep \"<[0-9].*\.2>\" ${CLU_1ST_LOG}/messages|egrep -v \"\.7>.*<Version|last message repeated|sendmail\"|tail -50"; EXEC_CMD_ONLY

  CATEGORY="mesg"; BODY="LOG_ERR <#.3> from 1st node current messages files"
  CMD="egrep \"<[0-9].*\.3>\" ${CLU_1ST_LOG}/messages|egrep -v \"\.7>.*<Version|last message repeated\|sendmail\"|wc -l"; EXEC_CMD
  CMD="egrep \"<[0-9].*\.3>\" ${CLU_1ST_LOG}/messages|egrep -v \"\.7>.*<Version|last message repeated\|sendmail\"|tail -50"; EXEC_CMD_ONLY
fi

CATEGORY="etc"; BODY="The number of NDMP Backup execution"
CMD="grep \"  <dumpdate\" ${IN_DIR}/local/ifsvar_modules.tar/modules/ndmp/dumpdates.xml|wc -l"; EXEC_CMD

CATEGORY="etc"; BODY="Checking Snapshot created from NDMP"
CMD="for NODE_FOR_NDMP in \`ls ${CLU_ALL}/varlog.tar/log/isi_ndmp_d|sort -t- -n -k${CLUSTER_NAME_DASH_COUNT_TEMP}\`; do echo \"--> \$NODE_FOR_NDMP <--\"; grep \"snapid: \" \$NODE_FOR_NDMP |tail -3 ; echo ; done"; EXEC_CMD

CATEGORY="smb"; BODY="lsassd.xml: Shows likewise (Active Directory integration daemon) configuration"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ $IS_ONEFS_version5 -eq 1 ]]; then
    $ECHO "# cksum ${CLU_ALL}/override.tar/override/lsassd.xml > /dev/null 2>&1\n"
    cksum ${CLU_ALL}/override.tar/override/lsassd.xml > /dev/null 2>&1
    if [[ $? -eq 1 ]]; then
      $ECHO "==> File Not Found"
    else
      CMD="cat ${IN_DIR}/${CLUSTER_NODE_FIRST}/override.tar/override/lsassd.xml"; EXEC_CMD_ONLY
    fi
  else
    $ECHO "# cksum ${CLU_ALL}/local_configs.tar/etc/mcp/override/lsassd.xml > /dev/null 2>&1\n"
    cksum ${CLU_ALL}/local_configs.tar/etc/mcp/override/lsassd.xml > /dev/null 2>&1
    if [[ $? -eq 1 ]]; then
      $ECHO "==> File Not Found"
    else
      CMD="cat ${IN_DIR}/${CLUSTER_NODE_FIRST}/local_configs.tar/etc/mcp/override/lsassd.xml"; EXEC_CMD_ONLY
    fi
  fi
fi

CATEGORY="etc"; BODY="License information"
CMD="cat ${IN_DIR}/local/isi_license"; EXEC_CMD

CATEGORY="network"; BODY="IB Retry messages"
CMD="grep Retry ${CLU_ALL}/isi_ib_bug_info|sort -t: -k2"; EXEC_CMD

CATEGORY="network"; BODY="Bug 43046 \"We should detect (and alert) when IB is not running at optimal link speed\""
CMD="egrep \"active_speed|enabled_speed|supported_speed\" ${CLU_ALL}/isi_ib_bug_info|cut -d: -f2-3|sort|uniq -c"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  WC_COUNT=`egrep "active_speed: 1" ${CLU_ALL}/isi_ib_bug_info|wc -l`
  if [[ $WC_COUNT -ne 0 ]]; then
    $ECHO ""
    CMD="egrep \"active_speed: 1\" ${CLU_ALL}/isi_ib_bug_info|sort -t- -n -k${CLUSTER_NAME_DASH_COUNT_TEMP}"; EXEC_CMD_ONLY
  fi
fi

CATEGORY="etc"; BODY="Information about patches that are installed on the cluster."
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ $RUNNING_ON_SOLARIS -eq 1 ]]; then
    WC_COUNT=`ls -1 ${CLU_ALL}/packages_local|xargs ${MD5}|awk '{print $4}'|sort|uniq -c|wc -l`
  else
    WC_COUNT=`ls -1 ${CLU_ALL}/packages_local|xargs ${MD5}|awk '{print $1}'|sort|uniq -c|wc -l`
  fi

  if [[ $WC_COUNT -eq 1 ]]; then
    if [[ $RUNNING_ON_SOLARIS -eq 1 ]]; then
      PACKAGES_LOCAL_MD5=`ls -1 ${CLU_ALL}/packages_local|xargs ${MD5}|awk '{print $4}'|sort|uniq`
    else
      PACKAGES_LOCAL_MD5=`ls -1 ${CLU_ALL}/packages_local|xargs ${MD5}|awk '{print $1}'|sort|uniq`
    fi

    if [[ $PACKAGES_LOCAL_MD5 == "572e01f42038211ee52290ca334709ce" ]]; then
      $ECHO "\n-------------------------------------------------------------------"
      $ECHO "                    No packages are installed."
      $ECHO "-------------------------------------------------------------------\n"
    else 
      $ECHO "\n-------------------------------------------------------------------"
      $ECHO "                  All installed patches are same"
      $ECHO "-------------------------------------------------------------------\n"
      CMD="cat ${IN_DIR}/${CLUSTER_NODE_FIRST}/packages_local"; EXEC_CMD_ONLY
    fi
  else
    $ECHO "\n-------------------------------------------------------------------"
    $ECHO "                    Installed patches are NOT same"
    $ECHO "-------------------------------------------------------------------\n"
    CMD="ls -l ${CLU_ALL}/packages_local"; EXEC_CMD_ONLY
    CMD="cat ${IN_DIR}/${CLUSTER_NODE_FIRST}/packages_local"; EXEC_CMD_ONLY
  fi
fi

CATEGORY="perf"; BODY="Added/Modified sysctl.conf"
CMD="cat ${IN_DIR}/local/ifsvar_etc.tar/etc/mcp/override/sysctl.conf"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  WC_COUNT=`ls -1 ${CLU_ALL}/local_configs.tar/etc/mcp/override/sysctl.conf ${IN_DIR}/local/ifsvar_etc.tar/etc/mcp/override/sysctl.conf|wc -l`
  if [[ $WC_COUNT -eq 0 ]]; then
    $ECHO "\n----------------------------------------"
    $ECHO "  override/sysctl.conf files NOT found"
    $ECHO "----------------------------------------\n"
  else
    if [[ $RUNNING_ON_SOLARIS -eq 1 ]]; then
      WC_COUNT=`ls -1 ${CLU_ALL}/local_configs.tar/etc/mcp/override/sysctl.conf ${IN_DIR}/local/ifsvar_etc.tar/etc/mcp/override/sysctl.conf|xargs $MD5|awk '{print $4}'|sort|uniq -c|wc -l`
    else
      WC_COUNT=`ls -1 ${CLU_ALL}/local_configs.tar/etc/mcp/override/sysctl.conf ${IN_DIR}/local/ifsvar_etc.tar/etc/mcp/override/sysctl.conf|xargs $MD5|awk '{print $1}'|sort|uniq -c|wc -l`
    fi

    if [[ $WC_COUNT -eq 1 ]]; then
      $ECHO "\n-------------------------------------------------------------------"
      $ECHO "  All override/sysctl.conf files on /ifs and local nodes are same"
      $ECHO "-------------------------------------------------------------------\n"
    fi
    if [[ `egrep "hw.disk_event.thresh.slowacc_single_act=[01]|hw.disk_event.thresh.slowfreq_act=[01]" ${IN_DIR}/local/ifsvar_etc.tar/etc/mcp/override/sysctl.conf|wc -l` -ne 0 ]]; then
      WARNING="** disabled \"drive stall\" triggered by slow I/O through below parameters **"; PRINT_WARNING
      if [[ `egrep "hw.disk_event.thresh.slowacc_single_act=[01]" ${IN_DIR}/local/ifsvar_etc.tar/etc/mcp/override/sysctl.conf|wc -l` -ne 0 ]]; then
        $ECHO "   hw.disk_event.thresh.slowacc_single_act\n   0=ignore, 1=warn, 2=softfail, 3=hardfail, 4=abort I/Os (default; puts drive into stalled state)"
      fi
      if [[ `egrep "hw.disk_event.thresh.slowfreq_act=[01]" ${IN_DIR}/local/ifsvar_etc.tar/etc/mcp/override/sysctl.conf|wc -l` -ne 0 ]]; then
        $ECHO ""
        $ECHO "   hw.disk_event.thresh.slowfreq_act\n   0=ignore, 1=warn, 2=softfail, 3=hardfail, 4=abort I/Os (default; puts drive into stalled state)"
      fi
    fi
  fi
fi

#CATEGORY="etc"; BODY="KB-473 : DIMM ECC error"
CATEGORY="etc"; BODY="KB 89662 : DIMM ECC error"
CMD="grep \"Correctable ECC error policy violation: \'burst error exceeds 15 error(s) in a 24 hours\" ${CLU_LATEST_MSG}"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `grep "Correctable ECC error policy violation: \'burst error exceeds 15 error(s) in a 24 hours" ${CLU_LATEST_MSG}|wc -l` -ge 1 ]]; then
    ALERT="DIMM Error: It might be related to KE-473: ECC error policy violation alert doesn't clear after replacing DIMM"; PRINT_ALERT
  fi
fi

CATEGORY="disk"; BODY="Listing ecclist insertions from isi_disk_inject file"
CMD="egrep -v \"^--Bay|Listing|<none>|Unsupported disk\" ${CLU_ALL}/isi_disk_inject|awk '{print \$2}'|xargs -i $GNU_GREP -B2 {} ${CLU_ALL}/isi_disk_inject|sort|uniq|grep Bay"; EXEC_CMD

#CATEGORY="firmware"; BODY="KB-2018: Rare drive failures on Hitachi Jupiter-K and Jupiter-U disk drives"
CATEGORY="firmware"; BODY="KB 88933: Rare drive failures on Hitachi Jupiter-K and Jupiter-U disk drives"
CMD="egrep \"HUA7220\" ${CLU_ALL_ISI_RADISH}|egrep \"FW:.....3[A-L][A-Z]\"|awk '{print \$4,\$5,\$6}'|sort|uniq -c"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `egrep "HUA7220" ${CLU_ALL_ISI_RADISH}|egrep "FW:.....3[A-L][A-Z]"|wc -l` -ne 0 ]]; then
    ALERT="This issue is caused by an issue in the Hitachi 2TB, 1TB, and 500GB drive firmware.\n         This issue is resolved in Hitachi drive firmware revision xxxxx3MA, xxxxx3PA, and later"; PRINT_ALERT
    #BODY="Check KB-2018 - 1st : The error message begins with a device reset"; PRINT_HEAD_LOOP
    BODY="Check KB 88933 - 1st : The error message begins with a device reset"; PRINT_HEAD_LOOP
    CMD="grep \"INTERNAL_DEVICE_RESET\" ${CLU_LATEST_MSG}|wc -l ; grep \"INTERNAL_DEVICE_RESET\" ${CLU_LATEST_MSG}| tail -1"; EXEC_CMD_ONLY
    #BODY="Check KB-2018 - 2nd : Look for Discovery failure error (Error stat) 0x4002"; PRINT_HEAD_LOOP
    BODY="Check KB 88933 - 2nd : Look for Discovery failure error (Error stat) 0x4002"; PRINT_HEAD_LOOP
    CMD="grep \"Discovery Error stat 0x4002\" ${CLU_LATEST_MSG}|wc -l ; grep \"Discovery Error stat 0x4002\" ${CLU_LATEST_MSG}| tail -1"; EXEC_CMD_ONLY
    #BODY="Check KB-2018 - 3rd : skipping pages of \"NOT READY asc:4c, 0 Logical unit failed self-configuration\" messages"; PRINT_HEAD_LOOP
    BODY="Check KB 88933 - 3rd : skipping pages of \"NOT READY asc:4c, 0 Logical unit failed self-configuration\" messages"; PRINT_HEAD_LOOP
    CMD="grep \"Logical unit failed self-configuration\" ${CLU_LATEST_MSG}|wc -l ; grep \"Logical unit failed self-configuration\" ${CLU_LATEST_MSG}| tail -1"; EXEC_CMD_ONLY
    #BODY="Check KB-2018 - 4th : The drive failure message (soft_fail = 1) is noted in the lines below"; PRINT_HEAD_LOOP
    BODY="Check KB 88933 - 4th : The drive failure message (soft_fail = 1) is noted in the lines below"; PRINT_HEAD_LOOP
    CMD="grep \"soft_fail = 1\" ${CLU_LATEST_MSG}|wc -l ; grep \"soft_fail = 1\" ${CLU_LATEST_MSG}| tail -1"; EXEC_CMD_ONLY
  fi
fi

CATEGORY="firmware"; BODY="Bug 75812(& Bug 99057 in compliance mode) -upgrade-on-join broken after installing IsiFw_Package"
CMD="grep IsiFw_Package ${CLU_ALL}/packages_local"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  WC_COUNT=`grep IsiFw_Package ${CLU_ALL}/packages_local|wc -l`
  if [[ $WC_COUNT -ne 0 ]]; then
    $ECHO "\n::::::::::::::::::::::::::::"
    $ECHO "  Found \"Firmware package\""
    $ECHO "::::::::::::::::::::::::::::"
    $ECHO "Per \"Isilon Node Firmware Package, Release number 8.3, Release notes\","
    $ECHO "\"\"\""
    $ECHO "2. After you confirm installation of the new firmware, remove the firmware package by"
    $ECHO "   typing the following command:"
    $ECHO "     isi pkg delete IsiFW_Package_v8.3"
    $ECHO "   Removing the firmware package files does not remove the firmware from the"
    $ECHO "   associated hardware."
    $ECHO "\"\"\"" 
    $ECHO ""
    CMD="grep \"isi_create_installtar error: Failed to regen the md5: \[Errno 2\] No such file or directory\" ${CLU_ALL_LOG_MSG}|sort -t: -k2 > ${TEMP_FILE}"; EXEC_CMD_ONLY
    WC_COUNT=`cat ${TEMP_FILE}|wc -l`
    if [[ $WC_COUNT -ne 0 ]]; then
      CMD="grep \"isi_create_installtar error: Failed to regen the md5: \[Errno 2\] No such file or directory\" ${TEMP_FILE}|wc -l"; EXEC_CMD_ONLY
      $ECHO ""
      CMD="grep \"isi_create_installtar error: Failed to regen the md5: \[Errno 2\] No such file or directory\" ${TEMP_FILE}|head -5"; EXEC_CMD_ONLY
      if [[ $WC_COUNT -gt 5 ]]; then
        if [[ $WC_COUNT -gt 10 ]]; then
          TAIL_COUNT=5
          $ECHO "\n...< might be snipped if count is over 10 >...\n"
        else
          $ECHO ""
          ((TAIL_COUNT=WC_COUNT-5))
        fi
        CMD="grep \"isi_create_installtar error: Failed to regen the md5: \[Errno 2\] No such file or directory\" ${TEMP_FILE}|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
      fi
      WARNING="If you encountered Bug 75812, the node would be able to join normally after removing the IsiFw_Package like below:"; PRINT_WARNING
      $ECHO "-------------------------------------------------------------------------------"
      $ECHO "  Per Isilon Firmware Package Release Notes,"
      $ECHO "  \"After you confirm installation of the new firmware,"
      $ECHO "   remove the firmware package by typing the following command:"
      $ECHO "   isi pkg delete <firmware package name>"
      $ECHO "   In the delete command, leave .tar off the end of the firmware package name."
      $ECHO "   Removing the firmware package files does not remove the firmware from the associated hardware.\""
      $ECHO "-------------------------------------------------------------------------------"
      $ECHO ""
      WARNING="Or, Bug 99057, in compliance, the node would be able to join normally after removing the IsiFw_Package like below:"; PRINT_WARNING
      $ECHO "-------------------------------------------------------------------------------"
      $ECHO "   isi pkg delete --forced_local <firmware package name>"
      $ECHO "-------------------------------------------------------------------------------"
    fi
  fi
  rm -f ${TEMP_FILE}
fi

PRINT_HW_STATUS=0
CATEGORY="firmware"; BODY="Firmware version (Not including Drive Firmware)"
CMD="egrep \"IsilonIB|DiskCtrl|DiskExp|Mellanox\" ${CLU_ALL}/etcifs.tar/ifs/firmware_versions|awk '{print \$2,\$3,\$4}'|sort|uniq -c"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  $ECHO "\n::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
  CMD="cat ${IN_DIR}/firmware"; EXEC_CMD_ONLY
  $ECHO "::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"

  if [[ `egrep "IsilonIB" ${CLU_ALL}/etcifs.tar/ifs/firmware_versions|awk '{print \$2,\$3,\$4}'|sort|uniq -c|wc -l` -gt 1 ]]; then
    WARNING="           IsilonIB firmware might be mixed          "; PRINT_WARNING
    PRINT_HW_STATUS=1
  fi
  if [[ `egrep "DiskCtrl" ${CLU_ALL}/etcifs.tar/ifs/firmware_versions|awk '{print \$2,\$3,\$4}'|sort|uniq -c|wc -l` -gt 1 ]]; then
    WARNING="           DiskCtrl firmware might be mixed          "; PRINT_WARNING
    PRINT_HW_STATUS=1
  fi
  if [[ `egrep "DiskExp" ${CLU_ALL}/etcifs.tar/ifs/firmware_versions|grep "LsiExp0"|awk '{print \$2,\$3,\$4}'|sort|uniq -c|wc -l` -gt 1 ]]; then
    WARNING="       LsiExp0 DiskExp firmware might be mixed       "; PRINT_WARNING
    PRINT_HW_STATUS=1
  fi
  if [[ `egrep "DiskExp" ${CLU_ALL}/etcifs.tar/ifs/firmware_versions|grep "LsiExp1"|awk '{print \$2,\$3,\$4}'|sort|uniq -c|wc -l` -gt 1 ]]; then
    WARNING="       LsiExp1 DiskExp firmware might be mixed       "; PRINT_WARNING
    PRINT_HW_STATUS=1
  fi
  if [[ `egrep "DiskExp" ${CLU_ALL}/etcifs.tar/ifs/firmware_versions|grep "Vitesse0"|awk '{print \$2,\$3,\$4}'|sort|uniq -c|wc -l` -gt 1 ]]; then
    WARNING="       Vitesse0 DiskExp firmware might be mixed      "; PRINT_WARNING
    PRINT_HW_STATUS=1
  fi
  if [[ `egrep "DiskExp" ${CLU_ALL}/etcifs.tar/ifs/firmware_versions|grep "Vitesse1"|awk '{print \$2,\$3,\$4}'|sort|uniq -c|wc -l` -gt 1 ]]; then
    WARNING="       Vitesse1 DiskExp firmware might be mixed      "; PRINT_WARNING
    PRINT_HW_STATUS=1
  fi

#  $ECHO "\n  As of Apr-1-2013, Latest firmware package release is "
#  $ECHO "  Isilon Firmware Package Version 8.2 (Release date: 11/05/2012)"
#  $ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#  $ECHO "  | Isilon Storage               | Platform Hardware Component | Firmware Version            |"
#  $ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#  $ECHO "  | IQ I-Series                  | Mellanox IB                 | 4.8.930+MT_02F0110001       |"
#  $ECHO "  |                              |                             | 4.8.930+MT_02F0110002       |"
#  $ECHO "  |                              |                             | 4.8.930+MT_0330110001       |"
#  $ECHO "  |                              |                             | 4.8.930+MT_02F0140002       |"
#  $ECHO "  |                              |                             | 4.8.930+MT_0330110002       |"
#  $ECHO "  |                              |                             | 4.8.930+MT_0330140002       |"
#  $ECHO "  |                              | 2 MB disk controller        | 6.28.00.00+01.28.02.00+1.17 |"
#  $ECHO "  |                              | 4 MB disk controller        | 6.28.00.00+01.28.02.00+1.17 |"
#  $ECHO "  |                              | SAS expander                | 0.99c                       |"
#  $ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#  $ECHO "  | IQ S-Series                  | IB/NVRAM                    | 4.8.930+205-0002-05_A       |"
#  $ECHO "  |                              | Disk controller             | 6.28.00.00+01.28.02.00+1.17 |"
#  $ECHO "  |                              | SAS expander                | 1.023                       |"
#  $ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#  $ECHO "  | 4U IQ NL and IQ X-Series     | IB/NVRAM                    | 4.8.930+205-0002-05_A       |"
#  $ECHO "  |                              | Disk controller             | 6.28.00.00+01.28.02.00+1.00 |"
#  $ECHO "  |                              | SAS expander                | 1.024                       |"
#  $ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#  $ECHO "  | 2U IQ X-Series               | IB/NVRAM                    | 4.8.930+205-0002-05_A       |"
#  $ECHO "  |                              | 2 MB disk controller        | 6.28.00.00+01.28.02.00+1.17 |"
#  $ECHO "  |                              | 4 MB disk controller        | 6.28.00.00+01.28.02.00+1.17 |"
#  $ECHO "  |                              | SAS expander                | 0.99c                       |"
#  $ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#  $ECHO "  | 1U EX                        | SAS expander                | 0.99c                       |"
#  $ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#  $ECHO "  | IQ 200                       | Disk controller             | 6.08.00.00+01.15.00.00+1.9  |"
#  $ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#  $ECHO "  | S200 Series and X200 Series  | SAS expander                | 0910+0210                   |"
#  $ECHO "  |                              | Disk Controller             | 12.00.00.00                 |"
#  $ECHO "  |                              | IB/NVRAM                    | 4.8.930+205-0002-05_A       |"
#  $ECHO "  |                              | Front panel                 | UI.01.29                    |"
#  $ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#  $ECHO "  | IQ 108NL /IQ 108000X         | IB/NVRAM                    | 4.8.930+205-0002-05_A       |"
#  $ECHO "  |                              | SAS expander                | 1.024                       |"
#  $ECHO "  |                              | Disk Controller             | 12.00.00.00                 |"
#  $ECHO "  |                              | Front panel                 | UI.01.29                    |"
#  $ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#  $ECHO "  | X400 Series and NL400 Series | SAS expander                | 0910+0210                   |"
#  $ECHO "  |                              | Disk Controller             | 12.00.00.00                 |"
#  $ECHO "  |                              | IB/NVRAM                    | 4.8.930+205-0002-05_A       |"
#  $ECHO "  |                              | Front panel                 | UI.01.29                    |"
#  $ECHO "  +------------------------------+-----------------------------+-----------------------------+"

#$ECHO "\n  As of Aug-18-2013, Latest firmware package release is"
#$ECHO "  Isilon Firmware Package Version 8.3 (Release date: Auguest, 2013)"
#$ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#$ECHO "  | Isilon Storage               | Platform Hardware Component | Firmware Version            |"
#$ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#$ECHO "  | IQ I-Series                  | Mellanox IB                 | 4.8.930+MT_02F0110001       |"
#$ECHO "  |                              |                             | 4.8.930+MT_02F0110002       |"
#$ECHO "  |                              |                             | 4.8.930+MT_0330110001       |"
#$ECHO "  |                              |                             | 4.8.930+MT_02F0140002       |"
#$ECHO "  |                              |                             | 4.8.930+MT_0330110002       |"
#$ECHO "  |                              |                             | 4.8.930+MT_0330140002       |"
#$ECHO "  |                              | 2 MB disk controller        | 6.28.00.00+01.28.02.00+1.17 |"
#$ECHO "  |                              | 4 MB disk controller        | 6.28.00.00+01.28.02.00+1.17 |"
#$ECHO "  |                              | SAS expander                | 0.99c                       |"
#$ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#$ECHO "  | IQ S-Series                  | IB/NVRAM                    | 4.8.930+205-0002-05_A       |"
#$ECHO "  |                              | Disk controller             | 6.28.00.00+01.28.02.00+1.17 |"
#$ECHO "  |                              | SAS expander                | 1.023                       |"
#$ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#$ECHO "  | 4U IQ NL and IQ X-Series     | IB/NVRAM                    | 4.8.930+205-0002-05_A       |"
#$ECHO "  |                              | Disk controller             | 6.28.00.00+01.28.02.00+1.00 |"
#$ECHO "  |                              | SAS expander                | 1.024                       |"
#$ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#$ECHO "  | 2U IQ X-Series               | IB/NVRAM                    | 4.8.930+205-0002-05_A       |"
#$ECHO "  |                              | 2 MB disk controller        | 6.28.00.00+01.28.02.00+1.17 |"
#$ECHO "  |                              | 4 MB disk controller        | 6.28.00.00+01.28.02.00+1.17 |"
#$ECHO "  |                              | SAS expander                | 0.99c                       |"
#$ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#$ECHO "  | 2U EX                        | SAS expander                | 0.99c                       |"
#$ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#$ECHO "  | S200 Series and X200 Series  | SAS expander                | 0910+0210                   |"
#$ECHO "  |                              | Disk Controller             | 16.00.01.00                 |"
#$ECHO "  |                              | IB/NVRAM                    | 4.8.930+205-0002-05_A       |"
#$ECHO "  |                              | Front panel                 | UI.01.29                    |"
#$ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#$ECHO "  | IQ 108NL /IQ 108000X         | IB/NVRAM                    | 4.8.930+205-0002-05_A       |"
#$ECHO "  |                              | SAS expander                | 1.024                       |"
#$ECHO "  |                              | Disk Controller             | 16.00.01.00                 |"
#$ECHO "  |                              | Front panel                 | UI.01.29                    |"
#$ECHO "  +------------------------------+-----------------------------+-----------------------------+"
#$ECHO "  | X400 Series and NL400 Series | SAS expander                | 0910+0210                   |"
#$ECHO "  |                              | Disk Controller             | 16.00.01.00                 |"
#$ECHO "  |                              | IB/NVRAM                    | 4.8.930+205-0002-05_A       |"
#$ECHO "  |                              | Front panel                 | UI.01.29                    |"
#$ECHO "  +------------------------------+-----------------------------+-----------------------------+"

$ECHO "\n  As of Mar-26-2014, Latest firmware package release is
  Isilon Firmware Package Version 9.0.1 (Release date: Mrch, 2014)
  +------------------------------+-----------------------------+-----------------------------+
  | Isilon Storage Platform      | Hardware Component          | Firmware Version            |
  +------------------------------+-----------------------------+-----------------------------+
  | IQ I-Series                  | IB                          | 4.8.930+MT_02F0110001       |
  |                              |                             | 4.8.930+MT_02F0110002       |
  |                              |                             | 4.8.930+MT_0330110001       |
  |                              |                             | 4.8.930+MT_02F0140002       |
  |                              |                             | 4.8.930+MT_0330110002       |
  |                              |                             | 4.8.930+MT_0330140002       |
  |                              | 2 MB disk controller        | 6.28.00.00+01.28.02.00+1.17 |
  |                              | 4 MB disk controller        | 6.28.00.00+01.28.02.00+1.17 |
  |                              | SAS expander                | 0.99c                       |
  +------------------------------+-----------------------------+-----------------------------+
  | IQ S-Series                  | IB/NVRAM                    | 4.8.930+205-0002-05_A       |
  |                              | Disk controller             | 6.28.00.00+01.28.02.00+1.17 |
  |                              | SAS expander                | 1.023                       |
  +------------------------------+-----------------------------+-----------------------------+
  | 4U IQ NL and IQ X-Series     | IB/NVRAM                    | 4.8.930+205-0002-05_A       |
  |                              | Disk controller             | 6.28.00.00+01.28.02.00+1.00 |
  |                              | SAS expander                | 1.024                       |
  +------------------------------+-----------------------------+-----------------------------+
  | 2U IQ X-Series               | IB/NVRAM                    | 4.8.930+205-0002-05_A       |
  |                              | 2 MB disk controller        | 6.28.00.00+01.28.02.00+1.17 |
  |                              | 4 MB disk controller        | 6.28.00.00+01.28.02.00+1.17 |
  |                              | SAS expander                | 0.99c                       |
  +------------------------------+-----------------------------+-----------------------------+
  | 2U EX                        | SAS expander                | 0.99c                       |
  +------------------------------+-----------------------------+-----------------------------+
  | S200 Series and X200 Series  | SAS expander                | 0910+0210                   |
  |                              | Disk Controller             | 16.00.01.00                 |
  |                              | IB/NVRAM                    | 4.8.930+205-0002-05_A       |
  |                              | Front panel                 | UI.01.29                    |
  +------------------------------+-----------------------------+-----------------------------+
  | IQ 108NL /IQ 108000X         | IB/NVRAM                    | 4.8.930+205-0002-05_A       |
  |                              | SAS expander                | 1.024                       |
  |                              | Disk Controller             | 16.00.01.00                 |
  |                              | Front panel                 | UI.01.29                    |
  +------------------------------+-----------------------------+-----------------------------+
  | X400 Series and NL400 Series | SAS expander                | 0910+0210                   |
  |                              | Disk Controller             | 16.00.01.00                 |
  |                              | IB/NVRAM                    | 4.8.930+205-0002-05_A       |
  |                              | Front panel                 | UI.01.29                    |
  +------------------------------+-----------------------------+-----------------------------+
  | A100 Performance             | IB                          | 2.30.8020                   |
  | and Backup Accelerators      |                             |                             |
  +------------------------------+-----------------------------+-----------------------------+"

  #if [[ PRINT_HW_STATUS -eq 1 ]]; then
    $ECHO ""
    CMD="awk '{print FILENAME,\$0}' ${CLU_ALL}/isi_hw_status |grep Product| sed 's:/isi_hw_status: :g' |sed 's:${IN_DIR}/::g'|sort -t\"-\" -n -k${CLUSTER_NAME_DASH_COUNT_TEMP}"; EXEC_CMD_ONLY
  #fi
fi

CATEGORY="smb"; BODY="SMBv2 credit Configuration"
CMD="$GNU_GREP -A30 \"Global Configuration:\" ${IN_DIR}/local/isi_smb|grep smb2 "; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  $ECHO "\n... Now ... checking [code:0x0000205] from lwiod.log files.... "
  if [[ `grep "code:0xc0000205" $CLU_ALL_LOG_LWIOD|wc -l` -ne 0 ]]; then
    CMD="grep \"code:0xc0000205\" $CLU_ALL_LOG_LWIOD|wc -l"; EXEC_CMD_ONLY
    CMD="grep \"code:0xc0000205\" $CLU_ALL_LOG_LWIOD|sort -t: -k2|tail -5"; EXEC_CMD_ONLY
    #ALERT="SMBv2 credit issue might be occurred, refer to KB-3929"; PRINT_ALERT
    ALERT="SMBv2 credit issue might be occurred, refer to KB 88534"; PRINT_ALERT
    $ECHO "\nThe meaning of \"code:0x0000205\" is as follows:"
    $ECHO "-----------------------------------------------------------------------"
    $ECHO "# isi auth error 0xc0000205"
    $ECHO "3221225989 = STATUS_INSUFF_SERVER_RESOURCES -> No description available"
    $ECHO "-----------------------------------------------------------------------\n"
    $ECHO "You would be able to resolve above error through increasing [smb2-client-credit-limit] and [smb2-global-credit-limit]\n"
  fi
fi

CATEGORY="smb"; BODY="SMB error: GSS-API error calling gss_accept_sec_context: 24 (Too many open files)"
CMD="grep 'GSS-API error calling gss_accept_sec_context: 24 (Too many open files)' $CLU_ALL_LOG_LWIOD|wc -l"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  WC_COUNT=`grep 'GSS-API error calling gss_accept_sec_context: 24 (Too many open files)' $CLU_ALL_LOG_LWIOD 2>/dev/null|wc -l`
  if [[ $WC_COUNT -ne 0 ]]; then
    $ECHO ""
    CMD="grep 'GSS-API error calling gss_accept_sec_context: 24 (Too many open files)' $CLU_ALL_LOG_LWIOD|sort -t: -k2|head -3"; EXEC_CMD_ONLY
    if [[ $WC_COUNT -gt 6 ]]; then
      TAIL_COUNT=3
      $ECHO "\n...< might be snipped if count is over 6 >...\n"
      CMD="grep 'GSS-API error calling gss_accept_sec_context: 24 (Too many open files)' $CLU_ALL_LOG_LWIOD|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
    elif [[ $WC_COUNT -gt 3 ]]; then
      $ECHO ""
      ((TAIL_COUNT=WC_COUNT-3))
      CMD="grep 'GSS-API error calling gss_accept_sec_context: 24 (Too many open files)' $CLU_ALL_LOG_LWIOD|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
    fi
    $ECHO "" 
    CMD="grep 'GSS-API error calling gss_accept_sec_context: 24 (Too many open files)' $CLU_ALL_LOG_LWIOD|sort -t: -k2|cut -d: -f2-10|cut -dT -f1|sort|uniq -c"; EXEC_CMD_ONLY
    ALERT=" SMB \"Too many open files\" Error, refer to Bug 97843 "; PRINT_ALERT
    $ECHO "\nDefault MaxOpenFileDescriptors in OneFS v6.5.X is as follows:"
    $ECHO "----------------------------------------------------------------------------"
    $ECHO "For example:"
    $ECHO "  # isi_gconfig registry.Services.lwio.Parameters.MaxOpenFileDescriptors"
    $ECHO "  registry.Services.lwio.Parameters.MaxOpenFileDescriptors (uint32) = 16384"
    $ECHO "----------------------------------------------------------------------------\n"
    $ECHO "If encountered \"Too many open file\", even if increased MaxOpenFileDescriptors to enough number"
    $ECHO "It might hit another limit resolved from \"Bug 98568 - FOPEN() and related calls break with large fd values\""
    $ECHO "This fixes fopen() by using an int(2147483647) for _file instead of short(32767)"
    $ECHO "It has been fixed on and after OneFS v6.5.5.13.\n"
    CMD="cat ${CLU_ALL}/uname|cut -d' ' -f7|uniq"; EXEC_CMD_ONLY
  fi
fi

CATEGORY="perf"; BODY="kern.openfiles (checking over 5000, issue might occur over 8000)"
CMD="grep \"kern.openfiles\" ${CLU_ALL}/kern.openfiles|sort -n -k2|sed 's:/kern.openfiles\:kern.openfiles::'|sed \"s:${IN_DIR}/::\""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `grep "kern.openfiles" ${CLU_ALL}/kern.openfiles|sort -n -k2|sed 's:/kern.openfiles\:kern.openfiles::'|sed "s:${IN_DIR}/::"|tail -1|awk '{print $2}'` -ge 5000 ]]; then
    #ALERT="This is usually a number around or below 1000.\n   The maximum files (sysctl kern.maxfiles) which can be open on a node is 16424 * CPU count.\n   If you are approaching this number, or are in the several thousand (8000+) open files,\n   this could lead to performance issues"; PRINT_ALERT
    $ECHO "\n   [1;41m==================================================================[0m"
    $ECHO "   [1;41mThis is usually a number around or below 1000.[0m"
    $ECHO "   [1;41mThe maximum files (sysctl kern.maxfiles) which can be open on a node is 16424 * CPU count.[0m"
    $ECHO "   [1;41mIf you are approaching this number, or are in the several thousand (8000+) open files,[0m"
    $ECHO "   [1;41mthis could lead to performance issues.[0m"
    $ECHO "   [1;41m==================================================================[0m\n"
  fi
fi

#CATEGORY="etc"; BODY="KB-830 : Cluster performance degraded because of a full /var partition"
CATEGORY="etc"; BODY="KB 89796 : Cluster performance degraded because of a full /var partition"
CMD="grep "Capacity" ${CLU_ALL}/df|head -1 ; grep \" /var$\" ${CLU_ALL}/df|sort -t\"-\" -n -k${CLUSTER_NAME_DASH_COUNT_TEMP}"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  DO_PRINT=0
  VAR_OVER_70=0
  VAR_CAPACITY=`grep "/var$" ${CLU_ALL}/df|awk '{print \$5}'|cut -d% -f1|xargs`
  for VAR_CAPACITY_EACH in $VAR_CAPACITY
  do
    if [[ $VAR_CAPACITY_EACH -ge 70 ]]; then
      VAR_OVER_70=1
    fi
  done
  if [[ $VAR_OVER_70 -eq 1 ]]; then
    #ALERT="/var partition capacity is over 70%, check KB-830    "; PRINT_ALERT
    ALERT="/var partition capacity is over 70%, check KB 89796   "; PRINT_ALERT
    CATEGORY="etc"; BODY="Bug 104651 : full /var partition due to the vsfptd stale file handle"
    CMD=""; EXEC_CMD
    #CMD="head -1 ${CLUSTER_NODE_FIRST}/fstat|awk '{print \"COUNT\",\$1,\$2,\$5,\$6,\$8,\$9}';grep vsftpd ${CLU_ALL}/fstat|grep \"/var\"|awk '\$8 > 50000000 {print \$1,\$2,\$5,\$6,\$8,\$9}'|sort|uniq -c"; EXEC_CMD_ONLY
    #CMD="egrep \"/var/log$|/var$\" ${CLU_ALL}/du|egrep -v \"/var/named/var/log$|/var/named/var$\""; EXEC_CMD_ONLY
    for EACH_NODE in $CLUSTER_NODE
    do
      DF_PERCENTAGE=`grep " /var$" ${IN_DIR}/${EACH_NODE}/df|awk '{print $5}'|cut -d% -f1|sed 's: ::g'`
      #$ECHO "EACH_NODE DF_PERCENTAGE : [ $EACH_NODE : $DF_PERCENTAGE ]"
      if [[ ${DF_PERCENTAGE}x == "x" ]]; then
        DF_PERCENTAGE=0
      fi
      if [[ $DF_PERCENTAGE -ge 70 ]]; then
        DO_PRINT=1
        if [[ `cat ${IN_DIR}/${EACH_NODE}/ps | grep vsftpd | grep -v grep | wc -l` -ge 2 ]]; then
          $ECHO "\n---------------------------------------------------------------------------------"
          $ECHO "  [ ${EACH_NODE} ] Checking the DU(1) result against /var and /var/log directories"
          $ECHO "---------------------------------------------------------------------------------"
          CMD="egrep \"/var/log$|/var$\" ${IN_DIR}/${EACH_NODE}/du|egrep -v \"/var/named/var/log$|/var/named/var$\""; EXEC_CMD_ONLY
          $ECHO ""
          CMD="head -1 ${IN_DIR}/${EACH_NODE}/fstat; grep vsftpd ${IN_DIR}/${EACH_NODE}/fstat|grep \"/var\"|awk '\$8 > 50000000 {print \$0}'|sort -n -k8|tail -4"; EXEC_CMD_ONLY
          WARNING="If above DU(1) result of /var is small, some process might be opening some log file even file has been already deleted"; PRINT_WARNING
          CMD="grep \`grep vsftpd ${IN_DIR}/${EACH_NODE}/fstat|grep "/var"|awk '\$8 > 50000000 {print \$0}'|sort -n -k8|tail -1|awk '{print \$3}'\` ${IN_DIR}/${EACH_NODE}/ps"; EXEC_CMD_ONLY
        fi
      fi
    done
    if [[ $DO_PRINT -eq 1 ]]; then
      $ECHO "\n  For example, if you find information in above, vsftpd might be the culprit, refer to Bug 104651, detail is in Bug 104651 #14 & #18"
      WARNING="Stale file handle issue could be resolved: refer to emc14003149"; PRINT_WARNING
      $ECHO "  \"\"\""
      $ECHO "  to use syslog for logging output instead of writing output to a log file." 
      $ECHO "  Syslog provides the ability to roll over files and limit file sizes, among other things."
      $ECHO "  \"\"\""
    fi
  fi
fi

CATEGORY="etc"; BODY="Checking over 99% /var/crash partition"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  DO_PRINT=0
  VAR_CRASH_OVER_99=0
  VAR_CRASH_CAPACITY=`grep "/var/crash$" ${CLU_ALL}/df|awk '{print \$5}'|cut -d% -f1|xargs`
  grep "Capacity" ${IN_DIR}/${CLUSTER_NODE_FIRST}/df|head -1
  for VAR_CRASH_CAPACITY_EACH in $VAR_CRASH_CAPACITY
  do
    if [[ $VAR_CRASH_CAPACITY_EACH -ge 99 ]]; then
      VAR_CRASH_OVER_99=1
    fi
  done
  if [[ $VAR_CRASH_OVER_99 -eq 1 ]]; then
    CMD="grep "Capacity" ${CLU_ALL}/df|head -1 ; grep \" /var/crash$\" ${CLU_ALL}/df|sort -t\"-\" -n -k${CLUSTER_NAME_DASH_COUNT_TEMP}"; EXEC_CMD_ONLY
    WARNING="  In some node(s), /var/crash capacity is over 99%   "; PRINT_WARNING
  fi
fi

#CATEGORY="nfs"; BODY="the number of nfsd threads allowed per node : KB-3086 : Slow NFS performance on OneFS 6.5.x with high client count [default: 16]"
CATEGORY="nfs"; BODY="the number of nfsd threads allowed per node : KB 89276 : Slow NFS performance on OneFS 6.5.x with high client count [default: 16]"
CMD="egrep \"vfs.nfsrv.rpc.minthreads|vfs.nfsrv.rpc.maxthreads|vfs.nfsrv.rpc.threads_min|vfs.nfsrv.rpc.threads_max\" ${CLU_ALL}/vfs.nfsrv|sort -t\"-\" -n -k${CLUSTER_NAME_DASH_COUNT_TEMP}"; EXEC_CMD

CATEGORY="nfs"; BODY="Bug 106939 - NFS swatchdog with socket closing and cantrecvmore"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  CMD="grep -h \"vfs.nfsrv.rpc.request_space_low\" ${CLU_ALL}/vfs.nfsrv|sort|uniq -c"; EXEC_CMD_ONLY
  $ECHO ""

  CMD="grep -h \"vfs.nfsrv.rpc.request_space_high\" ${CLU_ALL}/vfs.nfsrv|sort|uniq -c"; EXEC_CMD_ONLY
  NFSRV_RPC_REQUEST_SPACE_HIGH_COUNT=`grep -h "vfs.nfsrv.rpc.request_space_high" ${CLU_ALL}/vfs.nfsrv|sort|uniq|wc -l`
  if [[ $NFSRV_RPC_REQUEST_SPACE_HIGH_COUNT -gt 1 ]]; then
    $ECHO "  --> [vfs.nfsrv.rpc.request_space_high] values are not same on this cluster <--"
    NFSRV_RPC_REQUEST_SPACE_HIGH=`grep -h "vfs.nfsrv.rpc.request_space_high" ${CLU_ALL}/vfs.nfsrv|sort|uniq|sort -n -k2|tail -1|awk '{print $2}'`
  elif [[ $NFSRV_RPC_REQUEST_SPACE_HIGH_COUNT -eq 1 ]]; then
    NFSRV_RPC_REQUEST_SPACE_HIGH=`grep -h "vfs.nfsrv.rpc.request_space_high" ${CLU_ALL}/vfs.nfsrv|sort|uniq|awk '{print $2}'`
  fi
  $ECHO ""

  CMD="grep -h \"vfs.nfsrv.rpc.request_space_overcommit\" ${CLU_ALL}/vfs.nfsrv|sort|uniq -c"; EXEC_CMD_ONLY
  NFSRV_RPC_REQUEST_SPACE_OVERCOMMIT_COUNT=`grep -h "vfs.nfsrv.rpc.request_space_overcommit" ${CLU_ALL}/vfs.nfsrv|sort|uniq|wc -l`
  if [[ $NFSRV_RPC_REQUEST_SPACE_OVERCOMMIT_COUNT -gt 1 ]]; then
    $ECHO "  --> [vfs.nfsrv.rpc.request_space_overcommit] values are not same on this cluster <--"
    NFSRV_RPC_REQUEST_SPACE_OVERCOMMIT=`grep -h "vfs.nfsrv.rpc.request_space_overcommit" ${CLU_ALL}/vfs.nfsrv|sort|uniq|sort -n -k2|tail -1|awk '{print $2}'`
  elif [[ $NFSRV_RPC_REQUEST_SPACE_OVERCOMMIT_COUNT -eq 1 ]]; then
    NFSRV_RPC_REQUEST_SPACE_OVERCOMMIT=`grep -h "vfs.nfsrv.rpc.request_space_overcommit" ${CLU_ALL}/vfs.nfsrv|sort|uniq|awk '{print $2}'`
  elif [[ $NFSRV_RPC_REQUEST_SPACE_OVERCOMMIT_COUNT -eq 0 ]]; then
    $ECHO "[vfs.nfsrv.rpc.request_space_overcommit] Not Found\n"
    $ECHO "FYI, \"vfs.nfsrv.rpc.request_space_overcommit\" added from v6.5.5.12"
    PRINT_CURRENT_ONEFS_VERSION
  fi
  $ECHO ""

  CMD="grep \"vfs.nfsrv.rpc.request_space_used:\" ${CLU_ALL}/vfs.nfsrv|grep -v \"vfs.nfsrv.rpc.request_space_used: 0\"|sort -n -k2"; EXEC_CMD_ONLY
  $ECHO ""

  $ECHO "-----------------------------------------------------------------------------------"
  $ECHO "  List of [ vfs.nfsrv.rpc.request_space_used > vfs.nfsrv.rpc.request_space_high ]"
  $ECHO "-----------------------------------------------------------------------------------"
  CMD="grep \"vfs.nfsrv.rpc.request_space_used:\" ${CLU_ALL}/vfs.nfsrv|grep -v \"vfs.nfsrv.rpc.request_space_used: 0\"|awk '\$2>$NFSRV_RPC_REQUEST_SPACE_HIGH {print \$0}'|sort -n -k2"; EXEC_CMD_ONLY
  $ECHO "\n\n"

  CMD="grep \"vfs.nfsrv.rpc.request_space_used_highest:\" ${CLU_ALL}/vfs.nfsrv|sort -n -k2"; EXEC_CMD_ONLY
  $ECHO ""

  if [[ $NFSRV_RPC_REQUEST_SPACE_OVERCOMMIT_COUNT -ge 1 ]]; then
    $ECHO "-------------------------------------------------------------------------------------------------"
    $ECHO "  List of [ vfs.nfsrv.rpc.request_space_used_highest > vfs.nfsrv.rpc.request_space_overcommit ]"
    $ECHO "-------------------------------------------------------------------------------------------------"
    CMD="grep \"vfs.nfsrv.rpc.request_space_used_highest:\" ${CLU_ALL}/vfs.nfsrv|awk '\$2>$NFSRV_RPC_REQUEST_SPACE_OVERCOMMIT {print \$0}'|sort -n -k2|tee ${TEMP_FILE}"; EXEC_CMD_ONLY
    $ECHO ""
    OVER_NFSRV_RPC_REQUEST_SPACE_OVERCOMMIT_COUNT=`cat ${TEMP_FILE}|wc -l`
    if [[ $OVER_NFSRV_RPC_REQUEST_SPACE_OVERCOMMIT_COUNT -ge 1 ]]; then
      WARNING="This clsuter might hit Bug 106939 - NFS swatchdog with socket closing and cantrecvmore"; PRINT_WARNING
      $ECHO "\nBug 106939 has been fixed on and after OneFS v6.5.5.23 and v7.0.1.8"
      $ECHO "Before OneFS v6.5.5.23 and v7.0.1.8, Software Watchdog or other timout panic might be related to Bug 106939"
      PRINT_CURRENT_ONEFS_VERSION
      #$ECHO "\nThis cluster's version is:"
      #CMD="cat ${CLU_ALL}/uname|cut -d' ' -f7|uniq"; EXEC_CMD_ONLY
    fi
    rm ${TEMP_FILE}
  fi
fi

#CATEGORY="etc"; BODY="KB-3666 : How to fix an inode imbalance in OneFS 6.5"
CATEGORY="etc"; BODY="KB 16614 : How to fix an inode imbalance in OneFS 6.5"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ $IS_ONEFS_version5 -eq 1 ]]; then
    $ECHO "No field of [usedino] on OneFS v5.X version\n"
  else
    CMD="grep usedino ${CLU_ALL}/efs.lbm.drive_space|awk '{print \$1,\$2,\$5,\$7}'|sed 's:(::'|sed 's:=: :g'|sed 's:)::'|sed 's:,::g'|grep -v \"usedino 0\"|sort -n -k5|head -10"; EXEC_CMD_ONLY
    $ECHO ""
    CMD="grep usedino ${CLU_ALL}/efs.lbm.drive_space|awk '{print \$1,\$2,\$5,\$7}'|sed 's:(::'|sed 's:=: :g'|sed 's:)::'|sed 's:,::g'|grep -v \"usedino 0\"|sort -n -k5|tail -10"; EXEC_CMD_ONLY
  
    MIN_USED_INODE=`grep usedino ${CLU_ALL}/efs.lbm.drive_space|awk '{print $1,$2,$5,$7}'|sed 's:(::'|sed 's:=: :g'|sed 's:)::'|sed 's:,::g'|grep -v "usedino 0"|sort -n -k5|head -1|awk '{print $5}'`
    MAX_USED_INODE=`grep usedino ${CLU_ALL}/efs.lbm.drive_space|awk '{print $1,$2,$5,$7}'|sed 's:(::'|sed 's:=: :g'|sed 's:)::'|sed 's:,::g'|grep -v "usedino 0"|sort -n -k5|tail -1|awk '{print $5}'`
    DIFF_USED_INODE=`echo "scale = 2 ; $MAX_USED_INODE*100/$MIN_USED_INODE"|bc -l`
    $ECHO "\nMIN used Inode [ $MIN_USED_INODE ]"
    $ECHO "MAX used Inode [ $MAX_USED_INODE ]"
    $ECHO "Differece between MAX and MIN is [ $DIFF_USED_INODE % ]"
    $ECHO "\nCould be confirmed with the following commnad:"
    $ECHO "# isi statistics drive --nodes=all --long --orderby=inodes --type=sata,sas"
  fi
fi

CATEGORY="etc"; BODY="Checking DNS query issue"
CMD="grep \"Invalid hostname to sm_mon\" ${CLU_ALL_LOG_MSG}|wc -l"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `grep "Invalid hostname to sm_mon" ${CLU_ALL_LOG_MSG}|wc -l` -ne 0 ]]; then
    CMD="grep \"Invalid hostname to sm_mon\" ${CLU_ALL_LOG_MSG}|sort -t: -k2|tail -5"; EXEC_CMD_ONLY
    $ECHO ""
    CMD="grep \"Invalid hostname to sm_mon\" ${CLU_ALL_LOG_MSG}|awk '{print \$1}'|cut -d: -f2-10|cut -dT -f1|sort|uniq -c|tail"; EXEC_CMD_ONLY
  fi
fi

CATEGORY="etc"; BODY="Client lockd time-out due to the DNS query issue (Bug 96533)"
CMD="grep \"NLM: Failed to contact local NSM to monitor\" ${CLU_ALL_LOG_MSG}|wc -l"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ `grep "NLM: Failed to contact local NSM to monitor" ${CLU_ALL_LOG_MSG}|wc -l` -ne 0 ]]; then
    CMD="grep \"NLM: Failed to contact local NSM to monitor\" ${CLU_ALL_LOG_MSG}|sort -t: -k2|tail -5"; EXEC_CMD_ONLY
    $ECHO ""
    CMD="grep \"NLM: Failed to contact local NSM to monitor\" ${CLU_ALL_LOG_MSG}|awk '{print \$1}'|cut -d: -f2-10|cut -dT -f1|sort|uniq -c|tail"; EXEC_CMD_ONLY
  fi
fi

CATEGORY="cow"; BODY="Checking COWing(Copy-on-Write) thread from hangdump files"
#CMD="$ZGREP_E \"snap_cow|bam_coal_truncate_fast_cow|bam_safe_write_cow\" ${CLU_ALL}/isi_hangdump.tar/isi_hangdump*gz"; EXEC_CMD
#CMD="$ZGREP_E \"snap_cow|bam_coal_truncate_fast_cow\" ${CLU_ALL}/isi_hangdump.tar/isi_hangdump*gz"; EXEC_CMD
CMD="$ZGREP_E \"snap_cow|bam_coal_truncate_fast_cow\" ${CLU_ALL}/isi_hangdump.tar/isi_hangdump*"; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  #if [[ `$ZGREP_E "snap_cow|bam_coal_truncate_fast_cow|bam_safe_write_cow" ${CLU_ALL}/isi_hangdump.tar/isi_hangdump*gz 2> /dev/null|wc -l` -ne 0 ]]; then
  if [[ `$ZGREP_E "snap_cow|bam_coal_truncate_fast_cow" ${CLU_ALL}/isi_hangdump.tar/isi_hangdump*gz 2> /dev/null|wc -l` -ne 0 ]]; then
    WARNING="After creating hangdump graph, if some thread, such as nfsd, is holding exclusive lock for a long time, please refre to Bug-98552 and Bug-98973.\n         In case cluster-wide hung issue, isi_job_d might be involved, if so, please refter to Bug-96291";PRINT_WARNING
    if [[ $IS_ONEFS_version7 -eq 1 ]]; then
      $ECHO "======================================================================================"
      $ECHO "  In OneFS v7.X, COWing architecture has been changed, so above might be before v7.X"
      $ECHO "  Details regarding new \"system snapshot\" feature of OneFS v7.X is in emc14003975"
      $ECHO "======================================================================================\n"
      CMD="grep \": Isilon OneFS v7\" ${CLU_ALL_LOG_MSG}|sort -t: -k2|head -3"; EXEC_CMD_ONLY
    fi
  fi
fi

CATEGORY="synciq"; BODY="SyncIQ relating stuff"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ $RUNNING_ON_SOLARIS -eq 1 ]]; then
    if [[ `$MD5 ${CLU_ALL}/isi_sync_policy|awk '{print $4}'|sort|uniq -c|wc -l` -ne 1 ]]; then
      $ECHO ">>> isi_sync_policy are NOT same on each nodes"
    fi
  else
    if [[ `$MD5 ${CLU_ALL}/isi_sync_policy|awk '{print $1}'|sort|uniq -c|wc -l` -ne 1 ]]; then
      $ECHO ">>> isi_sync_policy are NOT same on each nodes"
    fi
  fi

  $ECHO "CLUSTER_NODE_FIRST : [$CLUSTER_NODE_FIRST]"
  $ECHO "1. \"Count of SyncIQ Policy\" and \"Target Clusters of SyncIQ\" is as follows:\n"
  CMD="cat ${IN_DIR}/${CLUSTER_NODE_FIRST}/isi_sync_policy|grep \"Cluster:\"|sort|uniq -c"; EXEC_CMD_ONLY

  $ECHO "\n\n2. \"Target Clusters of SyncIQ\" and \"interval\" is as follows:\n"
  CMD="cat ${IN_DIR}/${CLUSTER_NODE_FIRST}/isi_sync_policy|egrep \"Cluster:|Task:\""; EXEC_CMD_ONLY

  $ECHO "\n\n3. SyncIQ relating Error message in /var/log/messages\n"
  CMD="grep SyncIQ ${CLU_ALL_LOG_MSG}|grep -i error > ${TEMP_FILE}"; EXEC_CMD_ONLY
  WC_COUNT=`cat ${TEMP_FILE}|wc -l`
  if [[ $WC_COUNT -ne 0 ]]; then
    $ECHO ""
    CMD="cat ${TEMP_FILE}|wc -l"; EXEC_CMD_ONLY
    CMD="cat ${TEMP_FILE}|sort -t: -k2|head -5"; EXEC_CMD_ONLY
    if [[ $WC_COUNT -gt 5 ]]; then
      if [[ $WC_COUNT -gt 10 ]]; then
        TAIL_COUNT=5
        $ECHO "\n...< might be snipped if count is over 10 >...\n"
      else
        $ECHO ""
        ((TAIL_COUNT=WC_COUNT-5))
      fi
      if [[ PREVIOUS_CURRENT_V4_V5 -eq 1 ]]; then
        CMD="cat ${TEMP_FILE}|egrep -v \"${OLD_DATE_FORMAT}\"|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
      else
        CMD="cat ${TEMP_FILE}|sort -t: -k2|tail -${TAIL_COUNT}"; EXEC_CMD_ONLY
      fi
    fi
    if [[ `grep "Failed to delete user attribute DOSATTRIB" ${TEMP_FILE}|wc -l` -ne 0 ]];then
      BODY="Checking \"DOSATTRIB\" error message relating SyncIQ"; PRINT_HEAD_LOOP
      CMD="grep \"Failed to delete user attribute DOSATTRIB\" ${TEMP_FILE}|sort -t: -k2"; EXEC_CMD_ONLY
      ALERT="DOSATTRIB error has been filed on Bug 97933, as of Oct-17-12, it is under investigation"; PRINT_ALERT
    fi
    if [[ `grep "SyncIQ encountered a filesystem error on target cluster. Error at target cluster on node" ${TEMP_FILE}|grep "Unable to link"|wc -l` -ne 0 ]];then
      BODY="Checking possible problem - Bug96259(SyncIQ encountered a filesystem error on target cluster. Unable to open Lin 100080e68: No such file or directory error)"; PRINT_HEAD_LOOP
      CMD="grep \"SyncIQ encountered a filesystem error on target cluster. Error at target cluster on node\" ${TEMP_FILE}|grep \"Unable to link\"|tail -20"; EXEC_CMD_ONLY
      TARGET_ERROR_DIRECTORY=`grep "SyncIQ encountered a filesystem error on target cluster. Error at target cluster on node" ${TEMP_FILE}|grep "Unable to link"|tail -1|awk '{p1=index($0,"in directory ");p2=index($0,", Local error");u=substr($0,p1+13,p2-p1-13);print u}'`
      #WARNING="Please check directory [$TARGET_ERROR_DIRECTORY] on SyncIQ target cluster\n         above directory MUST exist on target cluster, but it seems like there is no directory\n         check the Salesforce case# 00248263"; PRINT_WARNING
    fi
  fi
  rm -f ${TEMP_FILE}
fi

CATEGORY="etc"; BODY="Bug 100864 : Checking issue of MAX_INT hertz, 248 days"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  CMD="grep load ${CLU_ALL}/uptime | sed 's:/uptime\:: :g' |grep \"days,\"|awk '\$4 > 247 {print \$0}'|sort -t- -n -k${CLUSTER_NAME_DASH_COUNT_TEMP}|tee ${TEMP_FILE}"; EXEC_CMD_ONLY
  if [[ `cat ${TEMP_FILE}|wc -l` -ne 0 ]]; then
    $ECHO "\n  Now, checking .. [ Waiting on ... with msg \"idmap_wait\" ] from hangdump files .....\n"
    if [[ `ls -1 ${CLU_ALL}/isi_hangdump.tar/isi_hangdump*gz 2>/dev/null | wc -l` -ne 0 ]]; then
      for I in `$ZGREP -l "with msg \"idmap_wait\"" ${CLU_ALL}/isi_hangdump.tar/isi_hangdump*gz`;
      do 
        $ECHO "# ${ZCAT} $I|${GNU_GREP} -A30 \"with msg \\\"idmap_wait\\\"|egrep \"efs.ko:idmap_opwait|efs.ko:idmap_rpc_wait|with msg \\\"idmap_wait\\\"\""
        ${ZCAT} $I|${GNU_GREP} -A30 "with msg \"idmap_wait\""|egrep "efs.ko:idmap_opwait|efs.ko:idmap_rpc_wait|with msg \"idmap_wait\"" | tee ${TEMP_FILE}
        $ECHO ""
        IDMAP_RPC_WAIT_CNT_TMP=`cat ${TEMP_FILE} | grep "efs.ko:idmap_rpc_wait" | wc -l`
        OPWAIT_CNT_TMP=`cat ${TEMP_FILE} | grep "efs.ko:idmap_opwait" | wc -l`
        ((IDMAP_RPC_WAIT_CNT+=IDMAP_RPC_WAIT_CNT_TMP))
        ((OPWAIT_CNT+=OPWAIT_CNT_TMP))
      done
      if [[ $IDMAP_RPC_WAIT_CNT -gt $OPWAIT_CNT ]]; then
        $ECHO ""
        CMD="cat ${CLU_ALL}/uname|cut -d' ' -f7|uniq"; EXEC_CMD_ONLY
        WARNING="A node uptime of 248 days or more resulted in an error when calculating timeouts for identity mapper lookups, causing an indefinite file system lock."; PRINT_WARNING
        ALERT="Please refer to Bug 100864 / Resolved on and after OneFS 6.5.5.18"; PRINT_ALERT
      else
        if [[ $IDMAP_RPC_WAIT_CNT -ne 0 ]]; then
          WARNING="If the stack involves opwait, it might not be the same issue with Bug 100864."; PRINT_WARNING
        fi
      fi
    fi
  fi
  rm -f ${TEMP_FILE}
fi

CATEGORY="nfs"; BODY="Bug 103781 : rpc.lockd hangup"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  CMD="grep \"with msg \\\"lkf_would_block\\\"\" ${CLU_ALL}/kern.proc.all_stacks|tee ${TEMP_FILE}"; EXEC_CMD_ONLY
  $ECHO ""
  if [[ `cat ${TEMP_FILE} | wc -l` -ge 1 ]]; then
    CMD="grep \"lkf_would_block\" ${CLU_ALL}/ps_full|tee ${TEMP_FILE}"; EXEC_CMD_ONLY
    $ECHO ""
    if [[ `cat ${TEMP_FILE} | wc -l` -ge 1 ]]; then
      CMD="egrep \"efs.ko:lkf_would_block|efs.ko:dev_local_lkf_would_block\" ${CLU_ALL}/kern.proc.all_stacks"; EXEC_CMD_ONLY
      ALERT="Bug 103781 issue might be occurred, try rebooting the node with the stack that includes \"dev_local_lkf_would_block\""; PRINT_ALERT
      $ECHO ""
      CMD="cat ${CLU_ALL}/uname|cut -d' ' -f7|uniq"; EXEC_CMD_ONLY
      WARNING="As of Apr-15-2013, this issue will be resolved on v6.5.5.20"; PRINT_WARNING
    fi
  fi
  rm -f ${TEMP_FILE}
fi

CATEGORY="nfs"; BODY="rpc.lockd process status check"
CMD="grep rpc.lo ${CLU_ALL}/ps_full|grep Ds"; EXEC_CMD
$ECHO ""
if [[ $RUN_OR_NOT -eq 1 ]]; then
  CMD="grep rpc.lo ${CLU_ALL}/ps|grep Ds"; EXEC_CMD_ONLY
  $ECHO ""
  CMD="grep rpc.lo ${CLU_ALL}/ps_full|grep Rs"; EXEC_CMD_ONLY
  if [[ `grep rpc.lo ${CLU_ALL}/ps_full|grep Ds|wc -l` -ne 0 ]]; then
    $ECHO "\n------------------------------------------------------------"
    $ECHO "  Checking rpc.lockd thread from kern.proc.all_stacks file"
    $ECHO "------------------------------------------------------------"
    FILE_HAVING_Ds_STATE=`grep rpc.lo ${CLU_ALL}/ps_full|grep Ds|head -1|awk '{print $1}'|cut -d: -f1`
    NODE_NAME_SLASH_COUNT_TEMP=`echo ${FILE_HAVING_Ds_STATE}|awk 'BEGIN{FS="/"}{for(i=1;i<=NF;i++)c++}END{print c}'`
    ((NODE_NAME_SLASH_COUNT=NODE_NAME_SLASH_COUNT_TEMP-1))
    NODE_HAVING_Ds_STATE=`echo $FILE_HAVING_Ds_STATE|cut -d/ -f${NODE_NAME_SLASH_COUNT}`
    #RPC_LOCKD_LINE=`egrep -n "[0-9].* rpc\.lockd" ${IN_DIR}/${NODE_HAVING_Ds_STATE}/kern.proc.all_stacks|cut -d: -f1`
    #$ECHO "RPC_LOCKD_LINE [$RPC_LOCKD_LINE]"
    CMD="$GNU_GREP -n -A25 \"[0-9].* rpc\.lockd\" ${IN_DIR}/${NODE_HAVING_Ds_STATE}/kern.proc.all_stacks"; EXEC_CMD_ONLY
    WARNING="rpc.lockd process is \"Un-interruptible\" state, that is, in kernel mode,\n         so even might not kill through SIGKILL(kill -9 PID)\n         It might be realted to LKF race bug (client_id mismatch)"; PRINT_WARNING
  fi

  if [[ `grep rpc.lo ${CLU_ALL}/ps_full|grep Rs|wc -l` -ne 0 ]]; then
    if [[ `grep rpc.lo ${CLU_ALL}/top|grep lkf_un|wc -l` -ne 0 ]]; then
      $ECHO "\n------------------------------------------------------------"
      $ECHO "  Checking rpc.lockd thread from kern.proc.all_stacks file"
      $ECHO "------------------------------------------------------------"
      FILE_HAVING_Rs_STATE=`grep rpc.lo ${CLU_ALL}/ps_full|grep Rs|head -1|awk '{print $1}'|cut -d: -f1`
      NODE_NAME_SLASH_COUNT_TEMP=`echo ${FILE_HAVING_Rs_STATE}|awk 'BEGIN{FS="/"}{for(i=1;i<=NF;i++)c++}END{print c}'`
      ((NODE_NAME_SLASH_COUNT=NODE_NAME_SLASH_COUNT_TEMP-1))
      NODE_HAVING_Rs_STATE=`echo $FILE_HAVING_Rs_STATE|cut -d/ -f${NODE_NAME_SLASH_COUNT}`
      CMD="$GNU_GREP -n -A25 \"[0-9].* rpc\.lockd\" ${IN_DIR}/${NODE_HAVING_Rs_STATE}/kern.proc.all_stacks"; EXEC_CMD_ONLY
      WARNING="rpc.lockd process is \"runnable process\" state, that is, in kernel mode,\n         In case \"ps\" command result is \"Ds\" status,\n         It might be realted to LKF race bug (client_id mismatch)"; PRINT_WARNING
    fi
  fi
fi

CATEGORY="network"; BODY="Listen Queue Overflows from \"netstat\" file"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  LISTEN_Q_OVERF_CNT_OVER=0
  $ECHO '+----------------------+-----+-----+-------------------+------------------------+'
  $ECHO '|            Node Name | LNN |  ID | ESTABLISHED Count | listen queue overflows |'
  $ECHO '+----------------------+-----+-----+-------------------+------------------------+'
  for EACH_NODE in $CLUSTER_NODE
  do
    printf "|%21s |" ${EACH_NODE}
    printf " %3s " `grep "${EACH_NODE} " ${IN_DIR}/nodes_info 2>/dev/null| awk '{print $4}'`
    printf "|"
    printf " %3s |" `grep "${EACH_NODE} " ${IN_DIR}/nodes_info 2>/dev/null| awk '{print $1}'`

    ESTABLISHED_CNT=`grep ESTABLISHED ${IN_DIR}/${EACH_NODE}/netstat 2>/dev/null|awk '{print $6}'|wc -l`
    if [[ $ESTABLISHED_CNT -gt 2000 ]]; then
      $ECHO "[1;31m\c "
      printf " %17s " $ESTABLISHED_CNT
      $ECHO "[1;0m\c "
    else
      printf " %17s " $ESTABLISHED_CNT
    fi
    printf "|"

    LISTEN_Q_OVERF_CNT=`grep "listen queue overflows" ${IN_DIR}/${EACH_NODE}/netstat 2>/dev/null|awk '{print $1}'`
    if [[ $LISTEN_Q_OVERF_CNT -gt 0 ]]; then
      $ECHO "[1;31m\c "
      printf " %22s " $LISTEN_Q_OVERF_CNT
      $ECHO "[1;0m\c "
      LISTEN_Q_OVERF_CNT_OVER=1
    else
      printf " %22s " $LISTEN_Q_OVERF_CNT
    fi
    printf "|\n"
  done
  $ECHO '+----------------------+-----+-----+-------------------+------------------------+'

  if [[ $LISTEN_Q_OVERF_CNT_OVER -eq 1 ]]; then
    $ECHO ":::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
    $ECHO "    [1;33mAbove \"listen queue overflows\" count is greater than 0(zero)[0m"
    $ECHO "    [1;33mThat would be a problem and we can give more headroom by adjusting[0m"
    $ECHO "    [1;33mkern.ipc.somaxconn 128 -> 256 (or something)[0m"
    $ECHO ""
    #$ECHO "    Please refer to Bug 109637 and KB-89680(https://support.emc.com/kb/89680)"
    $ECHO "    Please refer to Bug 109637 and KB 89680(https://support.emc.com/kb/89680)"
    $ECHO ":::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
    $ECHO "# man tuning"
    $ECHO "TUNING(7)          FreeBSD Miscellaneous Information Manual          TUNING(7)"
    $ECHO "NAME"
    $ECHO "     tuning -- performance tuning under FreeBSD"
    $ECHO "..."
    $ECHO "     The kern.ipc.somaxconn sysctl limits the size of the listen queue for"
    $ECHO "     accepting new TCP connections.  The default value of 128 is typically too"
    $ECHO "     low for robust handling of new connections in a heavily loaded web server"
    $ECHO "     environment.  For such environments, we recommend increasing this value"
    $ECHO "     to 1024 or higher.  The service daemon may itself limit the listen queue"
    $ECHO "     size (e.g. sendmail(8), apache) but will often have a directive in its"
    $ECHO "     configuration file to adjust the queue size up.  Larger listen queues"
    $ECHO "     also do a better job of fending off denial of service attacks."
    #$ECHO ""
    #$ECHO "[1;33mHow to change paramenter:[0m"
    #$ECHO "For instance)"
    #$ECHO "# sysctl kern.ipc.somaxconn"
    #$ECHO "kern.ipc.somaxconn: 128"
    #$ECHO "# sysctl kern.ipc.somaxconn=256"
    #$ECHO "kern.ipc.somaxconn: 128 -> 256"
    #$ECHO ""
    #$ECHO "[1;33mNote) Changing kern.ipc.somaxconn will increase the system limit.[0m"
    #$ECHO "[1;33m      It will not affect any applications that are currently running (like mountd)[0m"
    #$ECHO "# pkill -I mountd"
    #$ECHO "kill 60289 mountd? y"
    #$ECHO "# pgrep mountd"
    #$ECHO "60403"
    #$ECHO ""
    #$ECHO "[1;33mHow to confirm the change:[0m"
    #$ECHO "# netstat -anL | egrep 'listen|*.300'"
    #$ECHO "Current listen queue sizes (qlen/incqlen/maxqlen)"
    #$ECHO "tcp6  0/0/256        *.300"
    #$ECHO "tcp4  0/0/256        *.300"
    $ECHO ":::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
    $ECHO "\n  With regard to \"listen queue overflows\","
    $ECHO "  after checking Bug and KB above mentioned, if you still have a question,"
    $ECHO "  I'd recommend consult with Mark Foster. He is expert.\n"
    $ECHO ":::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
  fi
fi

CATEGORY="snapshot"; BODY="Snapshot schedule from \"override/snapshot_schedule.xml\""
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  CMD="cat $CLU_1ST/override.tar/override/snapshot_schedule.xml|grep \"snapshot expiration\"|wc -l" ; EXEC_CMD_ONLY
  CMD="cat $CLU_1ST/override.tar/override/snapshot_schedule.xml|grep \"snapshot expiration\"" ; EXEC_CMD_ONLY
fi

CATEGORY="protection"; BODY="Cluster Global Protection"
CMD=""; EXEC_CMD
if [[ $RUN_OR_NOT -eq 1 ]]; then
  if [[ $IS_ONEFS_version5 -eq 1 ]]; then
    $ECHO "# cksum ${CLU_ALL}/override.tar/override/global_protection.xml > /dev/null 2>&1\n"
    cksum ${CLU_ALL}/override.tar/override/global_protection.xml > /dev/null 2>&1
    if [[ $? -eq 1 ]]; then
      $ECHO "==> File Not Found"
    else
      if [[ `cksum ${CLU_ALL}/override.tar/override/global_protection.xml|awk '{print $1}'|sort|uniq|wc -l` -ne 1 ]]; then
        $ECHO ">>> global_protection.xml are NOT same on each nodes"
      fi
      if [[ -f ${IN_DIR}/${CLUSTER_NODE_FIRST}/override.tar/override/global_protection.xml ]]; then
        CMD="cat ${IN_DIR}/${CLUSTER_NODE_FIRST}/override.tar/override/global_protection.xml"; EXEC_CMD_ONLY
      else
        $ECHO "===> NOT Fount : ${IN_DIR}/${CLUSTER_NODE_FIRST}/override.tar/override/global_protection.xml"
      fi
    fi
  else
    $ECHO "# cksum ${CLU_ALL}/local_configs.tar/etc/mcp/sys/global_protection.xml > /dev/null 2>&1\n"
    cksum ${CLU_ALL}/local_configs.tar/etc/mcp/sys/global_protection.xml > /dev/null 2>&1
    if [[ $? -eq 1 ]]; then
      $ECHO "==> File Not Found"
    else
      if [[ `cksum ${CLU_ALL}/local_configs.tar/etc/mcp/sys/global_protection.xml|awk '{print $1}'|sort|uniq|wc -l` -ne 1 ]]; then
        $ECHO ">>> global_protection.xml are NOT same on each nodes"
      fi
      if [[ -f ${IN_DIR}/${CLUSTER_NODE_FIRST}/local_configs.tar/etc/mcp/sys/global_protection.xml ]]; then
        CMD="cat ${IN_DIR}/${CLUSTER_NODE_FIRST}/local_configs.tar/etc/mcp/sys/global_protection.xml"; EXEC_CMD_ONLY
      else
        $ECHO "===> NOT Fount : ${IN_DIR}/${CLUSTER_NODE_FIRST}/local_configs.tar/etc/mcp/sys/global_protection.xml"
      fi
    fi
  fi
fi

CATEGORY="protection"; BODY="Diskpool & Protection (# /usr/bin/disi -I diskpool list )"
CMD="cat ${IN_DIR}/local/isi_diskpool"; EXEC_CMD

#------------------- Please add new logic above this line --------------------#
if [[ $IS_ONEFS_version5 -eq 1 ]]; then
  ALERT="Date Sort would be terrible : Cluster version is v5.X"; PRINT_ALERT
elif [[ $IS_ONEFS_version7 -eq 1 ]]; then
  ALERT="               Cluster version is v7.X               "; PRINT_ALERT
fi

if [[ -f ${IN_DIR}/package_info.xml ]]; then
  $ECHO "\n\n================================================================"
  $ECHO "  This log set has been gathered through the following command:"
  $ECHO "[1;33m  # $ISI_GATHER_INFO_COMMAND [0m"
  $ECHO ""
  if [[ TIMEZONE_ENV_NULL -eq 1 ]]; then
    TIMEZONE=""
    $ECHO "  Collected on [1;33m[ $ISI_GATHER_INFO_LOCAL_DATE ][0m this system time, Not local time"
  else
    $ECHO "  Collected on [1;33m[ $ISI_GATHER_INFO_LOCAL_DATE ${TIMEZONE} ][0m Local Time"
  fi
  $ECHO "================================================================\n"
fi

$ECHO " ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
   Please note that this script does not provide any official information from EMC.
   All results are basically my personal opinion and check logic.

   In Dec 2011, I started to write this script to make my routine work (customer support) easy.
   And focused on personal interest of log set, then added some logics published on KB articles.

   I am still worrying that this script might mislead someone to wrong direction... 
   So, please make sure everything by yourself after getting information.

   I have tried to do my best to provide correct information, however, there will be many bugs.
   If you found a bug or something good source (and logic) to add in this script,
   please feel free to contact me via taesung.park@emc.com
 ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"

$ECHO "\n======================================================================="
$ECHO "  FYI,\n  if you want to redirect output to file, please run tpark this way,"
$ECHO "[1;33m  # echo | tpark | tee ~/OUTPUT.FILE.NAME [0m "
$ECHO "======================================================================="

###
## just for reference regarding Global parameter ##
###
#CLUSTER_NAME=`cat $IN_DIR/nodes_info|awk '{print $3}'|grep -v node|head -1|cut -d- -f1`
#CLUSTER_NODE=`cat $IN_DIR/nodes_info|awk '{print $3}'|grep -v node`
#CLUSTER_NODE_FIRST=`cat $IN_DIR/nodes_info|awk '{print $3}'|grep -v node|head -1`
#
#CLU_ALL="${IN_DIR}/${CLUSTER_NAME}-*"
#CLU_ALL_LOG="${CLU_ALL}/varlog.tar/log"
#CLU_LATEST_MSG="${CLU_ALL_LOG}/messages"
#CLU_ALL_LOG_MSG="${CLU_ALL_LOG}/messages*"
#CLU_ALL_LOG_ISI_SNAPSHOT_D="${CLU_ALL_LOG}/isi_snapshot_d.log*"
#CLU_ALL_LOG_ISI_MIGRATE="${CLU_ALL_LOG}/isi_migrate.log*"
#CLU_ALL_ISI_RADISH="${CLU_ALL}/isi_radish"
#CLU_1ST="${IN_DIR}/${CLUSTER_NODE_FIRST}"
#CLU_1ST_LOG="${IN_DIR}/${CLUSTER_NODE_FIRST}/varlog.tar/log"
#OLD_DATE_FORMAT="[Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec] .[0-9]"

$ECHO "\n[1;45m=============================== EOF ===================================[0m"
